{"version":3,"file":"msynth-worklet-B3DWMSX1.js","sources":["../src/signal.ts","../node_modules/ohm-js/src/common.js","../node_modules/ohm-js/src/UnicodeCategories.js","../node_modules/ohm-js/src/pexprs-main.js","../node_modules/ohm-js/src/errors.js","../node_modules/ohm-js/src/util.js","../node_modules/ohm-js/src/Interval.js","../node_modules/ohm-js/src/InputStream.js","../node_modules/ohm-js/src/MatchResult.js","../node_modules/ohm-js/src/PosInfo.js","../node_modules/ohm-js/src/Trace.js","../node_modules/ohm-js/src/pexprs-allowsSkippingPrecedingSpace.js","../node_modules/ohm-js/src/pexprs-assertAllApplicationsAreValid.js","../node_modules/ohm-js/src/pexprs-assertChoicesHaveUniformArity.js","../node_modules/ohm-js/src/pexprs-assertIteratedExprsAreNotNullable.js","../node_modules/ohm-js/src/nodes.js","../node_modules/ohm-js/src/pexprs-eval.js","../node_modules/ohm-js/src/pexprs-getArity.js","../node_modules/ohm-js/src/pexprs-outputRecipe.js","../node_modules/ohm-js/src/pexprs-introduceParams.js","../node_modules/ohm-js/src/pexprs-isNullable.js","../node_modules/ohm-js/src/pexprs-substituteParams.js","../node_modules/ohm-js/src/pexprs-toArgumentNameList.js","../node_modules/ohm-js/src/pexprs-toDisplayString.js","../node_modules/ohm-js/src/Failure.js","../node_modules/ohm-js/src/pexprs-toFailure.js","../node_modules/ohm-js/src/pexprs-toString.js","../node_modules/ohm-js/src/CaseInsensitiveTerminal.js","../node_modules/ohm-js/src/MatchState.js","../node_modules/ohm-js/src/Matcher.js","../node_modules/ohm-js/src/Semantics.js","../node_modules/ohm-js/src/Grammar.js","../node_modules/ohm-js/src/GrammarDecl.js","../node_modules/ohm-js/src/Builder.js","../node_modules/ohm-js/src/makeRecipe.js","../node_modules/ohm-js/dist/built-in-rules.js","../node_modules/ohm-js/src/main-kernel.js","../node_modules/ohm-js/dist/ohm-grammar.js","../node_modules/ohm-js/src/buildGrammar.js","../node_modules/ohm-js/dist/operations-and-attributes.js","../node_modules/ohm-js/src/semanticsDeferredInit.js","../node_modules/ohm-js/src/findIndentation.js","../node_modules/ohm-js/src/IndentationSensitive.js","../node_modules/ohm-js/src/main.js","../src/inlined-functions.ts","../src/built-in-signals.ts","../src/constants.ts","../src/env.ts","../src/glide.ts","../src/helpers.ts","../src/effects.ts","../src/ladder.ts","../src/msynth-lib.ts","../src/compiler.ts","../src/synth.ts","../src/midi-message-constructors.ts","../src/msynth-worklet.ts"],"sourcesContent":["import { Synth } from './synth';\n\ntype Config = {\n  nextSample: (synth: Synth) => number;\n  initialValue?: number;\n  noteOn?: (synth: Synth, retriggered: boolean) => void;\n  noteOff?: () => void;\n};\n\nexport class Signal {\n  private static newInstanceCollector: Signal[] | null = null;\n\n  static doCollectingNewInstances<T>(fn: () => T, collector: Signal[]): T {\n    const oldCollector = Signal.newInstanceCollector;\n    Signal.newInstanceCollector = collector;\n    try {\n      return fn();\n    } finally {\n      Signal.newInstanceCollector = oldCollector;\n    }\n  }\n\n  static new(config: ((synth: Synth) => number) | Config): Signal {\n    return typeof config === 'function'\n      ? new Signal(config)\n      : new Signal(config.nextSample, config.initialValue, config.noteOn, config.noteOff);\n  }\n\n  static scalar(value: number) {\n    return Signal.new({ nextSample: () => value, initialValue: value });\n  }\n\n  private constructor(\n    public readonly nextSample: (synth: Synth) => number,\n    public value = 0,\n    readonly noteOn?: (synth: Synth, retriggered: boolean) => void,\n    readonly noteOff?: () => void,\n    readonly writeSharedState?: (pushFn: (x: number) => void) => void,\n  ) {\n    Signal.newInstanceCollector?.push(this);\n  }\n\n  private lastFrameIdx = -1;\n  computeSample(frameIdx: number, synth: Synth) {\n    if (frameIdx !== this.lastFrameIdx) {\n      this.value = this.nextSample(synth);\n    }\n    return this.value;\n  }\n}\n\nexport const scalar = Signal.scalar;\n","// --------------------------------------------------------------------\n// Private Stuff\n// --------------------------------------------------------------------\n\n// Helpers\n\nconst escapeStringFor = {};\nfor (let c = 0; c < 128; c++) {\n  escapeStringFor[c] = String.fromCharCode(c);\n}\nescapeStringFor[\"'\".charCodeAt(0)] = \"\\\\'\";\nescapeStringFor['\"'.charCodeAt(0)] = '\\\\\"';\nescapeStringFor['\\\\'.charCodeAt(0)] = '\\\\\\\\';\nescapeStringFor['\\b'.charCodeAt(0)] = '\\\\b';\nescapeStringFor['\\f'.charCodeAt(0)] = '\\\\f';\nescapeStringFor['\\n'.charCodeAt(0)] = '\\\\n';\nescapeStringFor['\\r'.charCodeAt(0)] = '\\\\r';\nescapeStringFor['\\t'.charCodeAt(0)] = '\\\\t';\nescapeStringFor['\\u000b'.charCodeAt(0)] = '\\\\v';\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nexport function abstract(optMethodName) {\n  const methodName = optMethodName || '';\n  return function() {\n    throw new Error(\n        'this method ' +\n        methodName +\n        ' is abstract! ' +\n        '(it has no implementation in class ' +\n        this.constructor.name +\n        ')',\n    );\n  };\n}\n\nexport function assert(cond, message) {\n  if (!cond) {\n    throw new Error(message || 'Assertion failed');\n  }\n}\n\n// Define a lazily-computed, non-enumerable property named `propName`\n// on the object `obj`. `getterFn` will be called to compute the value the\n// first time the property is accessed.\nexport function defineLazyProperty(obj, propName, getterFn) {\n  let memo;\n  Object.defineProperty(obj, propName, {\n    get() {\n      if (!memo) {\n        memo = getterFn.call(this);\n      }\n      return memo;\n    },\n  });\n}\n\nexport function clone(obj) {\n  if (obj) {\n    return Object.assign({}, obj);\n  }\n  return obj;\n}\n\nexport function repeatFn(fn, n) {\n  const arr = [];\n  while (n-- > 0) {\n    arr.push(fn());\n  }\n  return arr;\n}\n\nexport function repeatStr(str, n) {\n  return new Array(n + 1).join(str);\n}\n\nexport function repeat(x, n) {\n  return repeatFn(() => x, n);\n}\n\nexport function getDuplicates(array) {\n  const duplicates = [];\n  for (let idx = 0; idx < array.length; idx++) {\n    const x = array[idx];\n    if (array.lastIndexOf(x) !== idx && duplicates.indexOf(x) < 0) {\n      duplicates.push(x);\n    }\n  }\n  return duplicates;\n}\n\nexport function copyWithoutDuplicates(array) {\n  const noDuplicates = [];\n  array.forEach(entry => {\n    if (noDuplicates.indexOf(entry) < 0) {\n      noDuplicates.push(entry);\n    }\n  });\n  return noDuplicates;\n}\n\nexport function isSyntactic(ruleName) {\n  const firstChar = ruleName[0];\n  return firstChar === firstChar.toUpperCase();\n}\n\nexport function isLexical(ruleName) {\n  return !isSyntactic(ruleName);\n}\n\nexport function padLeft(str, len, optChar) {\n  const ch = optChar || ' ';\n  if (str.length < len) {\n    return repeatStr(ch, len - str.length) + str;\n  }\n  return str;\n}\n\n// StringBuffer\n\nexport function StringBuffer() {\n  this.strings = [];\n}\n\nStringBuffer.prototype.append = function(str) {\n  this.strings.push(str);\n};\n\nStringBuffer.prototype.contents = function() {\n  return this.strings.join('');\n};\n\nconst escapeUnicode = str => String.fromCodePoint(parseInt(str, 16));\n\nexport function unescapeCodePoint(s) {\n  if (s.charAt(0) === '\\\\') {\n    switch (s.charAt(1)) {\n      case 'b':\n        return '\\b';\n      case 'f':\n        return '\\f';\n      case 'n':\n        return '\\n';\n      case 'r':\n        return '\\r';\n      case 't':\n        return '\\t';\n      case 'v':\n        return '\\v';\n      case 'x':\n        return escapeUnicode(s.slice(2, 4));\n      case 'u':\n        return s.charAt(2) === '{' ?\n          escapeUnicode(s.slice(3, -1)) :\n          escapeUnicode(s.slice(2, 6));\n      default:\n        return s.charAt(1);\n    }\n  } else {\n    return s;\n  }\n}\n\n// Helper for producing a description of an unknown object in a safe way.\n// Especially useful for error messages where an unexpected type of object was encountered.\nexport function unexpectedObjToString(obj) {\n  if (obj == null) {\n    return String(obj);\n  }\n  const baseToString = Object.prototype.toString.call(obj);\n  try {\n    let typeName;\n    if (obj.constructor && obj.constructor.name) {\n      typeName = obj.constructor.name;\n    } else if (baseToString.indexOf('[object ') === 0) {\n      typeName = baseToString.slice(8, -1); // Extract e.g. \"Array\" from \"[object Array]\".\n    } else {\n      typeName = typeof obj;\n    }\n    return typeName + ': ' + JSON.stringify(String(obj));\n  } catch (e) {\n    return baseToString;\n  }\n}\n\nexport function checkNotNull(obj, message = 'unexpected null value') {\n  if (obj == null) {\n    throw new Error(message);\n  }\n  return obj;\n}\n","// These are just categories that are used in ES5/ES2015.\n// The full list of Unicode categories is here: http://www.fileformat.info/info/unicode/category/index.htm.\nexport const UnicodeCategories = {\n  // Letters\n  Lu: /\\p{Lu}/u,\n  Ll: /\\p{Ll}/u,\n  Lt: /\\p{Lt}/u,\n  Lm: /\\p{Lm}/u,\n  Lo: /\\p{Lo}/u,\n\n  // Numbers\n  Nl: /\\p{Nl}/u,\n  Nd: /\\p{Nd}/u,\n\n  // Marks\n  Mn: /\\p{Mn}/u,\n  Mc: /\\p{Mc}/u,\n\n  // Punctuation, Connector\n  Pc: /\\p{Pc}/u,\n\n  // Separator, Space\n  Zs: /\\p{Zs}/u,\n\n  // These two are not real Unicode categories, but our useful for Ohm.\n  // L is a combination of all the letter categories.\n  // Ltmo is a combination of Lt, Lm, and Lo.\n  L: /\\p{Letter}/u,\n  Ltmo: /\\p{Lt}|\\p{Lm}|\\p{Lo}/u,\n};\n","import {UnicodeCategories} from './UnicodeCategories.js';\nimport * as common from './common.js';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// General stuff\n\nexport class PExpr {\n  constructor() {\n    if (this.constructor === PExpr) {\n      throw new Error(\"PExpr cannot be instantiated -- it's abstract\");\n    }\n  }\n\n  // Set the `source` property to the interval containing the source for this expression.\n  withSource(interval) {\n    if (interval) {\n      this.source = interval.trimmed();\n    }\n    return this;\n  }\n}\n\n// Any\n\nexport const any = Object.create(PExpr.prototype);\n\n// End\n\nexport const end = Object.create(PExpr.prototype);\n\n// Terminals\n\nexport class Terminal extends PExpr {\n  constructor(obj) {\n    super();\n    this.obj = obj;\n  }\n}\n\n// Ranges\n\nexport class Range extends PExpr {\n  constructor(from, to) {\n    super();\n    this.from = from;\n    this.to = to;\n    // If either `from` or `to` is made up of multiple code units, then\n    // the range should consume a full code point, not a single code unit.\n    this.matchCodePoint = from.length > 1 || to.length > 1;\n  }\n}\n\n// Parameters\n\nexport class Param extends PExpr {\n  constructor(index) {\n    super();\n    this.index = index;\n  }\n}\n\n// Alternation\n\nexport class Alt extends PExpr {\n  constructor(terms) {\n    super();\n    this.terms = terms;\n  }\n}\n\n// Extend is an implementation detail of rule extension\n\nexport class Extend extends Alt {\n  constructor(superGrammar, name, body) {\n    const origBody = superGrammar.rules[name].body;\n    super([body, origBody]);\n\n    this.superGrammar = superGrammar;\n    this.name = name;\n    this.body = body;\n  }\n}\n\n// Splice is an implementation detail of rule overriding with the `...` operator.\nexport class Splice extends Alt {\n  constructor(superGrammar, ruleName, beforeTerms, afterTerms) {\n    const origBody = superGrammar.rules[ruleName].body;\n    super([...beforeTerms, origBody, ...afterTerms]);\n\n    this.superGrammar = superGrammar;\n    this.ruleName = ruleName;\n    this.expansionPos = beforeTerms.length;\n  }\n}\n\n// Sequences\n\nexport class Seq extends PExpr {\n  constructor(factors) {\n    super();\n    this.factors = factors;\n  }\n}\n\n// Iterators and optionals\n\nexport class Iter extends PExpr {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n}\n\nexport class Star extends Iter {}\nexport class Plus extends Iter {}\nexport class Opt extends Iter {}\n\nStar.prototype.operator = '*';\nPlus.prototype.operator = '+';\nOpt.prototype.operator = '?';\n\nStar.prototype.minNumMatches = 0;\nPlus.prototype.minNumMatches = 1;\nOpt.prototype.minNumMatches = 0;\n\nStar.prototype.maxNumMatches = Number.POSITIVE_INFINITY;\nPlus.prototype.maxNumMatches = Number.POSITIVE_INFINITY;\nOpt.prototype.maxNumMatches = 1;\n\n// Predicates\n\nexport class Not extends PExpr {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n}\n\nexport class Lookahead extends PExpr {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n}\n\n// \"Lexification\"\n\nexport class Lex extends PExpr {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n}\n\n// Rule application\n\nexport class Apply extends PExpr {\n  constructor(ruleName, args = []) {\n    super();\n    this.ruleName = ruleName;\n    this.args = args;\n  }\n\n  isSyntactic() {\n    return common.isSyntactic(this.ruleName);\n  }\n\n  // This method just caches the result of `this.toString()` in a non-enumerable property.\n  toMemoKey() {\n    if (!this._memoKey) {\n      Object.defineProperty(this, '_memoKey', {value: this.toString()});\n    }\n    return this._memoKey;\n  }\n}\n\n// Unicode character\n\nexport class UnicodeChar extends PExpr {\n  constructor(category) {\n    super();\n    this.category = category;\n    this.pattern = UnicodeCategories[category];\n  }\n}\n","import {assert} from './common.js';\nimport * as pexprs from './pexprs-main.js';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nexport function createError(message, optInterval) {\n  let e;\n  if (optInterval) {\n    e = new Error(optInterval.getLineAndColumnMessage() + message);\n    e.shortMessage = message;\n    e.interval = optInterval;\n  } else {\n    e = new Error(message);\n  }\n  return e;\n}\n\n// ----------------- errors about intervals -----------------\n\nexport function intervalSourcesDontMatch() {\n  return createError(\"Interval sources don't match\");\n}\n\n// ----------------- errors about grammars -----------------\n\n// Grammar syntax error\n\nexport function grammarSyntaxError(matchFailure) {\n  const e = new Error();\n  Object.defineProperty(e, 'message', {\n    enumerable: true,\n    get() {\n      return matchFailure.message;\n    },\n  });\n  Object.defineProperty(e, 'shortMessage', {\n    enumerable: true,\n    get() {\n      return 'Expected ' + matchFailure.getExpectedText();\n    },\n  });\n  e.interval = matchFailure.getInterval();\n  return e;\n}\n\n// Undeclared grammar\n\nexport function undeclaredGrammar(grammarName, namespace, interval) {\n  const message = namespace ?\n    `Grammar ${grammarName} is not declared in namespace '${namespace}'` :\n    'Undeclared grammar ' + grammarName;\n  return createError(message, interval);\n}\n\n// Duplicate grammar declaration\n\nexport function duplicateGrammarDeclaration(grammar, namespace) {\n  return createError('Grammar ' + grammar.name + ' is already declared in this namespace');\n}\n\nexport function grammarDoesNotSupportIncrementalParsing(grammar) {\n  return createError(`Grammar '${grammar.name}' does not support incremental parsing`);\n}\n\n// ----------------- rules -----------------\n\n// Undeclared rule\n\nexport function undeclaredRule(ruleName, grammarName, optInterval) {\n  return createError(\n      'Rule ' + ruleName + ' is not declared in grammar ' + grammarName,\n      optInterval,\n  );\n}\n\n// Cannot override undeclared rule\n\nexport function cannotOverrideUndeclaredRule(ruleName, grammarName, optSource) {\n  return createError(\n      'Cannot override rule ' + ruleName + ' because it is not declared in ' + grammarName,\n      optSource,\n  );\n}\n\n// Cannot extend undeclared rule\n\nexport function cannotExtendUndeclaredRule(ruleName, grammarName, optSource) {\n  return createError(\n      'Cannot extend rule ' + ruleName + ' because it is not declared in ' + grammarName,\n      optSource,\n  );\n}\n\n// Duplicate rule declaration\n\nexport function duplicateRuleDeclaration(ruleName, grammarName, declGrammarName, optSource) {\n  let message =\n    \"Duplicate declaration for rule '\" + ruleName + \"' in grammar '\" + grammarName + \"'\";\n  if (grammarName !== declGrammarName) {\n    message += \" (originally declared in '\" + declGrammarName + \"')\";\n  }\n  return createError(message, optSource);\n}\n\n// Wrong number of parameters\n\nexport function wrongNumberOfParameters(ruleName, expected, actual, source) {\n  return createError(\n      'Wrong number of parameters for rule ' +\n      ruleName +\n      ' (expected ' +\n      expected +\n      ', got ' +\n      actual +\n      ')',\n      source,\n  );\n}\n\n// Wrong number of arguments\n\nexport function wrongNumberOfArguments(ruleName, expected, actual, expr) {\n  return createError(\n      'Wrong number of arguments for rule ' +\n      ruleName +\n      ' (expected ' +\n      expected +\n      ', got ' +\n      actual +\n      ')',\n      expr,\n  );\n}\n\n// Duplicate parameter names\n\nexport function duplicateParameterNames(ruleName, duplicates, source) {\n  return createError(\n      'Duplicate parameter names in rule ' + ruleName + ': ' + duplicates.join(', '),\n      source,\n  );\n}\n\n// Invalid parameter expression\n\nexport function invalidParameter(ruleName, expr) {\n  return createError(\n      'Invalid parameter to rule ' +\n      ruleName +\n      ': ' +\n      expr +\n      ' has arity ' +\n      expr.getArity() +\n      ', but parameter expressions must have arity 1',\n      expr.source,\n  );\n}\n\n// Application of syntactic rule from lexical rule\n\nconst syntacticVsLexicalNote =\n  'NOTE: A _syntactic rule_ is a rule whose name begins with a capital letter. ' +\n  'See https://ohmjs.org/d/svl for more details.';\n\nexport function applicationOfSyntacticRuleFromLexicalContext(ruleName, applyExpr) {\n  return createError(\n      'Cannot apply syntactic rule ' + ruleName + ' from here (inside a lexical context)',\n      applyExpr.source,\n  );\n}\n\n// Lexical rule application used with applySyntactic\n\nexport function applySyntacticWithLexicalRuleApplication(applyExpr) {\n  const {ruleName} = applyExpr;\n  return createError(\n      `applySyntactic is for syntactic rules, but '${ruleName}' is a lexical rule. ` +\n      syntacticVsLexicalNote,\n      applyExpr.source,\n  );\n}\n\n// Application of applySyntactic in a syntactic context\n\nexport function unnecessaryExperimentalApplySyntactic(applyExpr) {\n  return createError(\n      'applySyntactic is not required here (in a syntactic context)',\n      applyExpr.source,\n  );\n}\n\n// Incorrect argument type\n\nexport function incorrectArgumentType(expectedType, expr) {\n  return createError('Incorrect argument type: expected ' + expectedType, expr.source);\n}\n\n// Multiple instances of the super-splice operator (`...`) in the rule body.\n\nexport function multipleSuperSplices(expr) {\n  return createError(\"'...' can appear at most once in a rule body\", expr.source);\n}\n\n// Unicode code point escapes\n\nexport function invalidCodePoint(applyWrapper) {\n  const node = applyWrapper._node;\n  assert(node && node.isNonterminal() && node.ctorName === 'escapeChar_unicodeCodePoint');\n\n  // Get an interval that covers all of the hex digits.\n  const digitIntervals = applyWrapper.children.slice(1, -1).map(d => d.source);\n  const fullInterval = digitIntervals[0].coverageWith(...digitIntervals.slice(1));\n  return createError(\n      `U+${fullInterval.contents} is not a valid Unicode code point`,\n      fullInterval,\n  );\n}\n\n// ----------------- Kleene operators -----------------\n\nexport function kleeneExprHasNullableOperand(kleeneExpr, applicationStack) {\n  const actuals =\n    applicationStack.length > 0 ? applicationStack[applicationStack.length - 1].args : [];\n  const expr = kleeneExpr.expr.substituteParams(actuals);\n  let message =\n    'Nullable expression ' +\n    expr +\n    \" is not allowed inside '\" +\n    kleeneExpr.operator +\n    \"' (possible infinite loop)\";\n  if (applicationStack.length > 0) {\n    const stackTrace = applicationStack\n        .map(app => new pexprs.Apply(app.ruleName, app.args))\n        .join('\\n');\n    message += '\\nApplication stack (most recent application last):\\n' + stackTrace;\n  }\n  return createError(message, kleeneExpr.expr.source);\n}\n\n// ----------------- arity -----------------\n\nexport function inconsistentArity(ruleName, expected, actual, expr) {\n  return createError(\n      'Rule ' +\n      ruleName +\n      ' involves an alternation which has inconsistent arity ' +\n      '(expected ' +\n      expected +\n      ', got ' +\n      actual +\n      ')',\n      expr.source,\n  );\n}\n\n// ----------------- properties -----------------\n\nexport function duplicatePropertyNames(duplicates) {\n  return createError('Object pattern has duplicate property names: ' + duplicates.join(', '));\n}\n\n// ----------------- constructors -----------------\n\nexport function invalidConstructorCall(grammar, ctorName, children) {\n  return createError(\n      'Attempt to invoke constructor ' + ctorName + ' with invalid or unexpected arguments',\n  );\n}\n\n// ----------------- convenience -----------------\n\nexport function multipleErrors(errors) {\n  const messages = errors.map(e => e.message);\n  return createError(['Errors:'].concat(messages).join('\\n- '), errors[0].interval);\n}\n\n// ----------------- semantic -----------------\n\nexport function missingSemanticAction(ctorName, name, type, stack) {\n  let stackTrace = stack\n      .slice(0, -1)\n      .map(info => {\n        const ans = '  ' + info[0].name + ' > ' + info[1];\n        return info.length === 3 ? ans + \" for '\" + info[2] + \"'\" : ans;\n      })\n      .join('\\n');\n  stackTrace += '\\n  ' + name + ' > ' + ctorName;\n\n  let moreInfo = '';\n  if (ctorName === '_iter') {\n    moreInfo = [\n      '\\nNOTE: as of Ohm v16, there is no default action for iteration nodes — see ',\n      '  https://ohmjs.org/d/dsa for details.',\n    ].join('\\n');\n  }\n\n  const message = [\n    `Missing semantic action for '${ctorName}' in ${type} '${name}'.${moreInfo}`,\n    'Action stack (most recent call last):',\n    stackTrace,\n  ].join('\\n');\n\n  const e = createError(message);\n  e.name = 'missingSemanticAction';\n  return e;\n}\n\nexport function throwErrors(errors) {\n  if (errors.length === 1) {\n    throw errors[0];\n  }\n  if (errors.length > 1) {\n    throw multipleErrors(errors);\n  }\n}\n","import * as common from './common.js';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// Given an array of numbers `arr`, return an array of the numbers as strings,\n// right-justified and padded to the same length.\nfunction padNumbersToEqualLength(arr) {\n  let maxLen = 0;\n  const strings = arr.map(n => {\n    const str = n.toString();\n    maxLen = Math.max(maxLen, str.length);\n    return str;\n  });\n  return strings.map(s => common.padLeft(s, maxLen));\n}\n\n// Produce a new string that would be the result of copying the contents\n// of the string `src` onto `dest` at offset `offest`.\nfunction strcpy(dest, src, offset) {\n  const origDestLen = dest.length;\n  const start = dest.slice(0, offset);\n  const end = dest.slice(offset + src.length);\n  return (start + src + end).substr(0, origDestLen);\n}\n\n// Casts the underlying lineAndCol object to a formatted message string,\n// highlighting `ranges`.\nfunction lineAndColumnToMessage(...ranges) {\n  const lineAndCol = this;\n  const {offset} = lineAndCol;\n  const {repeatStr} = common;\n\n  const sb = new common.StringBuffer();\n  sb.append('Line ' + lineAndCol.lineNum + ', col ' + lineAndCol.colNum + ':\\n');\n\n  // An array of the previous, current, and next line numbers as strings of equal length.\n  const lineNumbers = padNumbersToEqualLength([\n    lineAndCol.prevLine == null ? 0 : lineAndCol.lineNum - 1,\n    lineAndCol.lineNum,\n    lineAndCol.nextLine == null ? 0 : lineAndCol.lineNum + 1,\n  ]);\n\n  // Helper for appending formatting input lines to the buffer.\n  const appendLine = (num, content, prefix) => {\n    sb.append(prefix + lineNumbers[num] + ' | ' + content + '\\n');\n  };\n\n  // Include the previous line for context if possible.\n  if (lineAndCol.prevLine != null) {\n    appendLine(0, lineAndCol.prevLine, '  ');\n  }\n  // Line that the error occurred on.\n  appendLine(1, lineAndCol.line, '> ');\n\n  // Build up the line that points to the offset and possible indicates one or more ranges.\n  // Start with a blank line, and indicate each range by overlaying a string of `~` chars.\n  const lineLen = lineAndCol.line.length;\n  let indicationLine = repeatStr(' ', lineLen + 1);\n  for (let i = 0; i < ranges.length; ++i) {\n    let startIdx = ranges[i][0];\n    let endIdx = ranges[i][1];\n    common.assert(startIdx >= 0 && startIdx <= endIdx, 'range start must be >= 0 and <= end');\n\n    const lineStartOffset = offset - lineAndCol.colNum + 1;\n    startIdx = Math.max(0, startIdx - lineStartOffset);\n    endIdx = Math.min(endIdx - lineStartOffset, lineLen);\n\n    indicationLine = strcpy(indicationLine, repeatStr('~', endIdx - startIdx), startIdx);\n  }\n  const gutterWidth = 2 + lineNumbers[1].length + 3;\n  sb.append(repeatStr(' ', gutterWidth));\n  indicationLine = strcpy(indicationLine, '^', lineAndCol.colNum - 1);\n  sb.append(indicationLine.replace(/ +$/, '') + '\\n');\n\n  // Include the next line for context if possible.\n  if (lineAndCol.nextLine != null) {\n    appendLine(2, lineAndCol.nextLine, '  ');\n  }\n  return sb.contents();\n}\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nlet builtInRulesCallbacks = [];\n\n// Since Grammar.BuiltInRules is bootstrapped, most of Ohm can't directly depend it.\n// This function allows modules that do depend on the built-in rules to register a callback\n// that will be called later in the initialization process.\nexport function awaitBuiltInRules(cb) {\n  builtInRulesCallbacks.push(cb);\n}\n\nexport function announceBuiltInRules(grammar) {\n  builtInRulesCallbacks.forEach(cb => {\n    cb(grammar);\n  });\n  builtInRulesCallbacks = null;\n}\n\n// Return an object with the line and column information for the given\n// offset in `str`.\nexport function getLineAndColumn(str, offset) {\n  let lineNum = 1;\n  let colNum = 1;\n\n  let currOffset = 0;\n  let lineStartOffset = 0;\n\n  let nextLine = null;\n  let prevLine = null;\n  let prevLineStartOffset = -1;\n\n  while (currOffset < offset) {\n    const c = str.charAt(currOffset++);\n    if (c === '\\n') {\n      lineNum++;\n      colNum = 1;\n      prevLineStartOffset = lineStartOffset;\n      lineStartOffset = currOffset;\n    } else if (c !== '\\r') {\n      colNum++;\n    }\n  }\n\n  // Find the end of the target line.\n  let lineEndOffset = str.indexOf('\\n', lineStartOffset);\n  if (lineEndOffset === -1) {\n    lineEndOffset = str.length;\n  } else {\n    // Get the next line.\n    const nextLineEndOffset = str.indexOf('\\n', lineEndOffset + 1);\n    nextLine =\n      nextLineEndOffset === -1 ?\n        str.slice(lineEndOffset) :\n        str.slice(lineEndOffset, nextLineEndOffset);\n    // Strip leading and trailing EOL char(s).\n    nextLine = nextLine.replace(/^\\r?\\n/, '').replace(/\\r$/, '');\n  }\n\n  // Get the previous line.\n  if (prevLineStartOffset >= 0) {\n    // Strip trailing EOL char(s).\n    prevLine = str.slice(prevLineStartOffset, lineStartOffset).replace(/\\r?\\n$/, '');\n  }\n\n  // Get the target line, stripping a trailing carriage return if necessary.\n  const line = str.slice(lineStartOffset, lineEndOffset).replace(/\\r$/, '');\n\n  return {\n    offset,\n    lineNum,\n    colNum,\n    line,\n    prevLine,\n    nextLine,\n    toString: lineAndColumnToMessage,\n  };\n}\n\n// Return a nicely-formatted string describing the line and column for the\n// given offset in `str` highlighting `ranges`.\nexport function getLineAndColumnMessage(str, offset, ...ranges) {\n  return getLineAndColumn(str, offset).toString(...ranges);\n}\n\nexport const uniqueId = (() => {\n  let idCounter = 0;\n  return prefix => '' + prefix + idCounter++;\n})();\n","import {assert} from './common.js';\nimport * as errors from './errors.js';\nimport * as util from './util.js';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nexport class Interval {\n  constructor(sourceString, startIdx, endIdx) {\n    this.sourceString = sourceString;\n    this.startIdx = startIdx;\n    this.endIdx = endIdx;\n  }\n\n  get contents() {\n    if (this._contents === undefined) {\n      this._contents = this.sourceString.slice(this.startIdx, this.endIdx);\n    }\n    return this._contents;\n  }\n\n  get length() {\n    return this.endIdx - this.startIdx;\n  }\n\n  coverageWith(...intervals) {\n    return Interval.coverage(...intervals, this);\n  }\n\n  collapsedLeft() {\n    return new Interval(this.sourceString, this.startIdx, this.startIdx);\n  }\n\n  collapsedRight() {\n    return new Interval(this.sourceString, this.endIdx, this.endIdx);\n  }\n\n  getLineAndColumn() {\n    return util.getLineAndColumn(this.sourceString, this.startIdx);\n  }\n\n  getLineAndColumnMessage() {\n    const range = [this.startIdx, this.endIdx];\n    return util.getLineAndColumnMessage(this.sourceString, this.startIdx, range);\n  }\n\n  // Returns an array of 0, 1, or 2 intervals that represents the result of the\n  // interval difference operation.\n  minus(that) {\n    if (this.sourceString !== that.sourceString) {\n      throw errors.intervalSourcesDontMatch();\n    } else if (this.startIdx === that.startIdx && this.endIdx === that.endIdx) {\n      // `this` and `that` are the same interval!\n      return [];\n    } else if (this.startIdx < that.startIdx && that.endIdx < this.endIdx) {\n      // `that` splits `this` into two intervals\n      return [\n        new Interval(this.sourceString, this.startIdx, that.startIdx),\n        new Interval(this.sourceString, that.endIdx, this.endIdx),\n      ];\n    } else if (this.startIdx < that.endIdx && that.endIdx < this.endIdx) {\n      // `that` contains a prefix of `this`\n      return [new Interval(this.sourceString, that.endIdx, this.endIdx)];\n    } else if (this.startIdx < that.startIdx && that.startIdx < this.endIdx) {\n      // `that` contains a suffix of `this`\n      return [new Interval(this.sourceString, this.startIdx, that.startIdx)];\n    } else {\n      // `that` and `this` do not overlap\n      return [this];\n    }\n  }\n\n  // Returns a new Interval that has the same extent as this one, but which is relative\n  // to `that`, an Interval that fully covers this one.\n  relativeTo(that) {\n    if (this.sourceString !== that.sourceString) {\n      throw errors.intervalSourcesDontMatch();\n    }\n    assert(\n        this.startIdx >= that.startIdx && this.endIdx <= that.endIdx,\n        'other interval does not cover this one',\n    );\n    return new Interval(\n        this.sourceString,\n        this.startIdx - that.startIdx,\n        this.endIdx - that.startIdx,\n    );\n  }\n\n  // Returns a new Interval which contains the same contents as this one,\n  // but with whitespace trimmed from both ends.\n  trimmed() {\n    const {contents} = this;\n    const startIdx = this.startIdx + contents.match(/^\\s*/)[0].length;\n    const endIdx = this.endIdx - contents.match(/\\s*$/)[0].length;\n    return new Interval(this.sourceString, startIdx, endIdx);\n  }\n\n  subInterval(offset, len) {\n    const newStartIdx = this.startIdx + offset;\n    return new Interval(this.sourceString, newStartIdx, newStartIdx + len);\n  }\n}\n\nInterval.coverage = function(firstInterval, ...intervals) {\n  let {startIdx, endIdx} = firstInterval;\n  for (const interval of intervals) {\n    if (interval.sourceString !== firstInterval.sourceString) {\n      throw errors.intervalSourcesDontMatch();\n    } else {\n      startIdx = Math.min(startIdx, interval.startIdx);\n      endIdx = Math.max(endIdx, interval.endIdx);\n    }\n  }\n  return new Interval(firstInterval.sourceString, startIdx, endIdx);\n};\n","import {Interval} from './Interval.js';\n\nconst MAX_CHAR_CODE = 0xffff;\n\nexport class InputStream {\n  constructor(source) {\n    this.source = source;\n    this.pos = 0;\n    this.examinedLength = 0;\n  }\n\n  atEnd() {\n    const ans = this.pos >= this.source.length;\n    this.examinedLength = Math.max(this.examinedLength, this.pos + 1);\n    return ans;\n  }\n\n  next() {\n    const ans = this.source[this.pos++];\n    this.examinedLength = Math.max(this.examinedLength, this.pos);\n    return ans;\n  }\n\n  nextCharCode() {\n    const nextChar = this.next();\n    return nextChar && nextChar.charCodeAt(0);\n  }\n\n  nextCodePoint() {\n    const cp = this.source.slice(this.pos++).codePointAt(0);\n    // If the code point is beyond plane 0, it takes up two characters.\n    if (cp > MAX_CHAR_CODE) {\n      this.pos += 1;\n    }\n    this.examinedLength = Math.max(this.examinedLength, this.pos);\n    return cp;\n  }\n\n  matchString(s, optIgnoreCase) {\n    let idx;\n    if (optIgnoreCase) {\n      /*\n        Case-insensitive comparison is a tricky business. Some notable gotchas include the\n        \"Turkish I\" problem (http://www.i18nguy.com/unicode/turkish-i18n.html) and the fact\n        that the German Esszet (ß) turns into \"SS\" in upper case.\n\n        This is intended to be a locale-invariant comparison, which means it may not obey\n        locale-specific expectations (e.g. \"i\" => \"İ\").\n       */\n      for (idx = 0; idx < s.length; idx++) {\n        const actual = this.next();\n        const expected = s[idx];\n        if (actual == null || actual.toUpperCase() !== expected.toUpperCase()) {\n          return false;\n        }\n      }\n      return true;\n    }\n    // Default is case-sensitive comparison.\n    for (idx = 0; idx < s.length; idx++) {\n      if (this.next() !== s[idx]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  sourceSlice(startIdx, endIdx) {\n    return this.source.slice(startIdx, endIdx);\n  }\n\n  interval(startIdx, optEndIdx) {\n    return new Interval(this.source, startIdx, optEndIdx ? optEndIdx : this.pos);\n  }\n}\n","import * as common from './common.js';\nimport * as util from './util.js';\nimport {Interval} from './Interval.js';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nexport class MatchResult {\n  constructor(\n      matcher,\n      input,\n      startExpr,\n      cst,\n      cstOffset,\n      rightmostFailurePosition,\n      optRecordedFailures,\n  ) {\n    this.matcher = matcher;\n    this.input = input;\n    this.startExpr = startExpr;\n    this._cst = cst;\n    this._cstOffset = cstOffset;\n    this._rightmostFailurePosition = rightmostFailurePosition;\n    this._rightmostFailures = optRecordedFailures;\n\n    if (this.failed()) {\n      /* eslint-disable no-invalid-this */\n      common.defineLazyProperty(this, 'message', function() {\n        const detail = 'Expected ' + this.getExpectedText();\n        return (\n          util.getLineAndColumnMessage(this.input, this.getRightmostFailurePosition()) + detail\n        );\n      });\n      common.defineLazyProperty(this, 'shortMessage', function() {\n        const detail = 'expected ' + this.getExpectedText();\n        const errorInfo = util.getLineAndColumn(\n            this.input,\n            this.getRightmostFailurePosition(),\n        );\n        return 'Line ' + errorInfo.lineNum + ', col ' + errorInfo.colNum + ': ' + detail;\n      });\n      /* eslint-enable no-invalid-this */\n    }\n  }\n\n  succeeded() {\n    return !!this._cst;\n  }\n\n  failed() {\n    return !this.succeeded();\n  }\n\n  getRightmostFailurePosition() {\n    return this._rightmostFailurePosition;\n  }\n\n  getRightmostFailures() {\n    if (!this._rightmostFailures) {\n      this.matcher.setInput(this.input);\n      const matchResultWithFailures = this.matcher._match(this.startExpr, {\n        tracing: false,\n        positionToRecordFailures: this.getRightmostFailurePosition(),\n      });\n      this._rightmostFailures = matchResultWithFailures.getRightmostFailures();\n    }\n    return this._rightmostFailures;\n  }\n\n  toString() {\n    return this.succeeded() ?\n      '[match succeeded]' :\n      '[match failed at position ' + this.getRightmostFailurePosition() + ']';\n  }\n\n  // Return a string summarizing the expected contents of the input stream when\n  // the match failure occurred.\n  getExpectedText() {\n    if (this.succeeded()) {\n      throw new Error('cannot get expected text of a successful MatchResult');\n    }\n\n    const sb = new common.StringBuffer();\n    let failures = this.getRightmostFailures();\n\n    // Filter out the fluffy failures to make the default error messages more useful\n    failures = failures.filter(failure => !failure.isFluffy());\n\n    for (let idx = 0; idx < failures.length; idx++) {\n      if (idx > 0) {\n        if (idx === failures.length - 1) {\n          sb.append(failures.length > 2 ? ', or ' : ' or ');\n        } else {\n          sb.append(', ');\n        }\n      }\n      sb.append(failures[idx].toString());\n    }\n    return sb.contents();\n  }\n\n  getInterval() {\n    const pos = this.getRightmostFailurePosition();\n    return new Interval(this.input, pos, pos);\n  }\n}\n","export class PosInfo {\n  constructor() {\n    this.applicationMemoKeyStack = []; // active applications at this position\n    this.memo = {};\n    this.maxExaminedLength = 0;\n    this.maxRightmostFailureOffset = -1;\n    this.currentLeftRecursion = undefined;\n  }\n\n  isActive(application) {\n    return this.applicationMemoKeyStack.indexOf(application.toMemoKey()) >= 0;\n  }\n\n  enter(application) {\n    this.applicationMemoKeyStack.push(application.toMemoKey());\n  }\n\n  exit() {\n    this.applicationMemoKeyStack.pop();\n  }\n\n  startLeftRecursion(headApplication, memoRec) {\n    memoRec.isLeftRecursion = true;\n    memoRec.headApplication = headApplication;\n    memoRec.nextLeftRecursion = this.currentLeftRecursion;\n    this.currentLeftRecursion = memoRec;\n\n    const {applicationMemoKeyStack} = this;\n    const indexOfFirstInvolvedRule =\n      applicationMemoKeyStack.indexOf(headApplication.toMemoKey()) + 1;\n    const involvedApplicationMemoKeys = applicationMemoKeyStack.slice(\n        indexOfFirstInvolvedRule,\n    );\n\n    memoRec.isInvolved = function(applicationMemoKey) {\n      return involvedApplicationMemoKeys.indexOf(applicationMemoKey) >= 0;\n    };\n\n    memoRec.updateInvolvedApplicationMemoKeys = function() {\n      for (let idx = indexOfFirstInvolvedRule; idx < applicationMemoKeyStack.length; idx++) {\n        const applicationMemoKey = applicationMemoKeyStack[idx];\n        if (!this.isInvolved(applicationMemoKey)) {\n          involvedApplicationMemoKeys.push(applicationMemoKey);\n        }\n      }\n    };\n  }\n\n  endLeftRecursion() {\n    this.currentLeftRecursion = this.currentLeftRecursion.nextLeftRecursion;\n  }\n\n  // Note: this method doesn't get called for the \"head\" of a left recursion -- for LR heads,\n  // the memoized result (which starts out being a failure) is always used.\n  shouldUseMemoizedResult(memoRec) {\n    if (!memoRec.isLeftRecursion) {\n      return true;\n    }\n    const {applicationMemoKeyStack} = this;\n    for (let idx = 0; idx < applicationMemoKeyStack.length; idx++) {\n      const applicationMemoKey = applicationMemoKeyStack[idx];\n      if (memoRec.isInvolved(applicationMemoKey)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  memoize(memoKey, memoRec) {\n    this.memo[memoKey] = memoRec;\n    this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);\n    this.maxRightmostFailureOffset = Math.max(\n        this.maxRightmostFailureOffset,\n        memoRec.rightmostFailureOffset,\n    );\n    return memoRec;\n  }\n\n  clearObsoleteEntries(pos, invalidatedIdx) {\n    if (pos + this.maxExaminedLength <= invalidatedIdx) {\n      // Optimization: none of the rule applications that were memoized here examined the\n      // interval of the input that changed, so nothing has to be invalidated.\n      return;\n    }\n\n    const {memo} = this;\n    this.maxExaminedLength = 0;\n    this.maxRightmostFailureOffset = -1;\n    Object.keys(memo).forEach(k => {\n      const memoRec = memo[k];\n      if (pos + memoRec.examinedLength > invalidatedIdx) {\n        delete memo[k];\n      } else {\n        this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);\n        this.maxRightmostFailureOffset = Math.max(\n            this.maxRightmostFailureOffset,\n            memoRec.rightmostFailureOffset,\n        );\n      }\n    });\n  }\n}\n","import {Interval} from './Interval.js';\nimport * as common from './common.js';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// Unicode characters that are used in the `toString` output.\nconst BALLOT_X = '\\u2717';\nconst CHECK_MARK = '\\u2713';\nconst DOT_OPERATOR = '\\u22C5';\nconst RIGHTWARDS_DOUBLE_ARROW = '\\u21D2';\nconst SYMBOL_FOR_HORIZONTAL_TABULATION = '\\u2409';\nconst SYMBOL_FOR_LINE_FEED = '\\u240A';\nconst SYMBOL_FOR_CARRIAGE_RETURN = '\\u240D';\n\nconst Flags = {\n  succeeded: 1 << 0,\n  isRootNode: 1 << 1,\n  isImplicitSpaces: 1 << 2,\n  isMemoized: 1 << 3,\n  isHeadOfLeftRecursion: 1 << 4,\n  terminatesLR: 1 << 5,\n};\n\nfunction spaces(n) {\n  return common.repeat(' ', n).join('');\n}\n\n// Return a string representation of a portion of `input` at offset `pos`.\n// The result will contain exactly `len` characters.\nfunction getInputExcerpt(input, pos, len) {\n  const excerpt = asEscapedString(input.slice(pos, pos + len));\n\n  // Pad the output if necessary.\n  if (excerpt.length < len) {\n    return excerpt + common.repeat(' ', len - excerpt.length).join('');\n  }\n  return excerpt;\n}\n\nfunction asEscapedString(obj) {\n  if (typeof obj === 'string') {\n    // Replace non-printable characters with visible symbols.\n    return obj\n        .replace(/ /g, DOT_OPERATOR)\n        .replace(/\\t/g, SYMBOL_FOR_HORIZONTAL_TABULATION)\n        .replace(/\\n/g, SYMBOL_FOR_LINE_FEED)\n        .replace(/\\r/g, SYMBOL_FOR_CARRIAGE_RETURN);\n  }\n  return String(obj);\n}\n\n// ----------------- Trace -----------------\n\nexport class Trace {\n  constructor(input, pos1, pos2, expr, succeeded, bindings, optChildren) {\n    this.input = input;\n    this.pos = this.pos1 = pos1;\n    this.pos2 = pos2;\n    this.source = new Interval(input, pos1, pos2);\n    this.expr = expr;\n    this.bindings = bindings;\n    this.children = optChildren || [];\n    this.terminatingLREntry = null;\n\n    this._flags = succeeded ? Flags.succeeded : 0;\n  }\n\n  get displayString() {\n    return this.expr.toDisplayString();\n  }\n\n  clone() {\n    return this.cloneWithExpr(this.expr);\n  }\n\n  cloneWithExpr(expr) {\n    const ans = new Trace(\n        this.input,\n        this.pos,\n        this.pos2,\n        expr,\n        this.succeeded,\n        this.bindings,\n        this.children,\n    );\n\n    ans.isHeadOfLeftRecursion = this.isHeadOfLeftRecursion;\n    ans.isImplicitSpaces = this.isImplicitSpaces;\n    ans.isMemoized = this.isMemoized;\n    ans.isRootNode = this.isRootNode;\n    ans.terminatesLR = this.terminatesLR;\n    ans.terminatingLREntry = this.terminatingLREntry;\n    return ans;\n  }\n\n  // Record the trace information for the terminating condition of the LR loop.\n  recordLRTermination(ruleBodyTrace, value) {\n    this.terminatingLREntry = new Trace(\n        this.input,\n        this.pos,\n        this.pos2,\n        this.expr,\n        false,\n        [value],\n        [ruleBodyTrace],\n    );\n    this.terminatingLREntry.terminatesLR = true;\n  }\n\n  // Recursively traverse this trace node and all its descendents, calling a visitor function\n  // for each node that is visited. If `vistorObjOrFn` is an object, then its 'enter' property\n  // is a function to call before visiting the children of a node, and its 'exit' property is\n  // a function to call afterwards. If `visitorObjOrFn` is a function, it represents the 'enter'\n  // function.\n  //\n  // The functions are called with three arguments: the Trace node, its parent Trace, and a number\n  // representing the depth of the node in the tree. (The root node has depth 0.) `optThisArg`, if\n  // specified, is the value to use for `this` when executing the visitor functions.\n  walk(visitorObjOrFn, optThisArg) {\n    let visitor = visitorObjOrFn;\n    if (typeof visitor === 'function') {\n      visitor = {enter: visitor};\n    }\n\n    function _walk(node, parent, depth) {\n      let recurse = true;\n      if (visitor.enter) {\n        if (visitor.enter.call(optThisArg, node, parent, depth) === Trace.prototype.SKIP) {\n          recurse = false;\n        }\n      }\n      if (recurse) {\n        node.children.forEach(child => {\n          _walk(child, node, depth + 1);\n        });\n        if (visitor.exit) {\n          visitor.exit.call(optThisArg, node, parent, depth);\n        }\n      }\n    }\n    if (this.isRootNode) {\n      // Don't visit the root node itself, only its children.\n      this.children.forEach(c => {\n        _walk(c, null, 0);\n      });\n    } else {\n      _walk(this, null, 0);\n    }\n  }\n\n  // Return a string representation of the trace.\n  // Sample:\n  //     12⋅+⋅2⋅*⋅3 ✓ exp ⇒  \"12\"\n  //     12⋅+⋅2⋅*⋅3   ✓ addExp (LR) ⇒  \"12\"\n  //     12⋅+⋅2⋅*⋅3       ✗ addExp_plus\n  toString() {\n    const sb = new common.StringBuffer();\n    this.walk((node, parent, depth) => {\n      if (!node) {\n        return this.SKIP;\n      }\n      const ctorName = node.expr.constructor.name;\n      // Don't print anything for Alt nodes.\n      if (ctorName === 'Alt') {\n        return; // eslint-disable-line consistent-return\n      }\n      sb.append(getInputExcerpt(node.input, node.pos, 10) + spaces(depth * 2 + 1));\n      sb.append((node.succeeded ? CHECK_MARK : BALLOT_X) + ' ' + node.displayString);\n      if (node.isHeadOfLeftRecursion) {\n        sb.append(' (LR)');\n      }\n      if (node.succeeded) {\n        const contents = asEscapedString(node.source.contents);\n        sb.append(' ' + RIGHTWARDS_DOUBLE_ARROW + '  ');\n        sb.append(typeof contents === 'string' ? '\"' + contents + '\"' : contents);\n      }\n      sb.append('\\n');\n    });\n    return sb.contents();\n  }\n}\n\n// A value that can be returned from visitor functions to indicate that a\n// node should not be recursed into.\nTrace.prototype.SKIP = {};\n\n// For convenience, create a getter and setter for the boolean flags in `Flags`.\nObject.keys(Flags).forEach(name => {\n  const mask = Flags[name];\n  Object.defineProperty(Trace.prototype, name, {\n    get() {\n      return (this._flags & mask) !== 0;\n    },\n    set(val) {\n      if (val) {\n        this._flags |= mask;\n      } else {\n        this._flags &= ~mask;\n      }\n    },\n  });\n});\n","import {abstract} from './common.js';\nimport * as pexprs from './pexprs-main.js';\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  Return true if we should skip spaces preceding this expression in a syntactic context.\n*/\npexprs.PExpr.prototype.allowsSkippingPrecedingSpace = abstract('allowsSkippingPrecedingSpace');\n\n/*\n  Generally, these are all first-order expressions and (with the exception of Apply)\n  directly read from the input stream.\n*/\npexprs.any.allowsSkippingPrecedingSpace =\n  pexprs.end.allowsSkippingPrecedingSpace =\n  pexprs.Apply.prototype.allowsSkippingPrecedingSpace =\n  pexprs.Terminal.prototype.allowsSkippingPrecedingSpace =\n  pexprs.Range.prototype.allowsSkippingPrecedingSpace =\n  pexprs.UnicodeChar.prototype.allowsSkippingPrecedingSpace =\n    function() {\n      return true;\n    };\n\n/*\n  Higher-order expressions that don't directly consume input.\n*/\npexprs.Alt.prototype.allowsSkippingPrecedingSpace =\n  pexprs.Iter.prototype.allowsSkippingPrecedingSpace =\n  pexprs.Lex.prototype.allowsSkippingPrecedingSpace =\n  pexprs.Lookahead.prototype.allowsSkippingPrecedingSpace =\n  pexprs.Not.prototype.allowsSkippingPrecedingSpace =\n  pexprs.Param.prototype.allowsSkippingPrecedingSpace =\n  pexprs.Seq.prototype.allowsSkippingPrecedingSpace =\n    function() {\n      return false;\n    };\n","import {abstract, isSyntactic} from './common.js';\nimport * as errors from './errors.js';\nimport * as pexprs from './pexprs-main.js';\nimport * as util from './util.js';\n\nlet BuiltInRules;\n\nutil.awaitBuiltInRules(g => {\n  BuiltInRules = g;\n});\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\nlet lexifyCount;\n\npexprs.PExpr.prototype.assertAllApplicationsAreValid = function(ruleName, grammar) {\n  lexifyCount = 0;\n  this._assertAllApplicationsAreValid(ruleName, grammar);\n};\n\npexprs.PExpr.prototype._assertAllApplicationsAreValid = abstract(\n    '_assertAllApplicationsAreValid',\n);\n\npexprs.any._assertAllApplicationsAreValid =\n  pexprs.end._assertAllApplicationsAreValid =\n  pexprs.Terminal.prototype._assertAllApplicationsAreValid =\n  pexprs.Range.prototype._assertAllApplicationsAreValid =\n  pexprs.Param.prototype._assertAllApplicationsAreValid =\n  pexprs.UnicodeChar.prototype._assertAllApplicationsAreValid =\n    function(ruleName, grammar) {\n      // no-op\n    };\n\npexprs.Lex.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {\n  lexifyCount++;\n  this.expr._assertAllApplicationsAreValid(ruleName, grammar);\n  lexifyCount--;\n};\n\npexprs.Alt.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {\n  for (let idx = 0; idx < this.terms.length; idx++) {\n    this.terms[idx]._assertAllApplicationsAreValid(ruleName, grammar);\n  }\n};\n\npexprs.Seq.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {\n  for (let idx = 0; idx < this.factors.length; idx++) {\n    this.factors[idx]._assertAllApplicationsAreValid(ruleName, grammar);\n  }\n};\n\npexprs.Iter.prototype._assertAllApplicationsAreValid =\n  pexprs.Not.prototype._assertAllApplicationsAreValid =\n  pexprs.Lookahead.prototype._assertAllApplicationsAreValid =\n    function(ruleName, grammar) {\n      this.expr._assertAllApplicationsAreValid(ruleName, grammar);\n    };\n\npexprs.Apply.prototype._assertAllApplicationsAreValid = function(\n    ruleName,\n    grammar,\n    skipSyntacticCheck = false,\n) {\n  const ruleInfo = grammar.rules[this.ruleName];\n  const isContextSyntactic = isSyntactic(ruleName) && lexifyCount === 0;\n\n  // Make sure that the rule exists...\n  if (!ruleInfo) {\n    throw errors.undeclaredRule(this.ruleName, grammar.name, this.source);\n  }\n\n  // ...and that this application is allowed\n  if (!skipSyntacticCheck && isSyntactic(this.ruleName) && !isContextSyntactic) {\n    throw errors.applicationOfSyntacticRuleFromLexicalContext(this.ruleName, this);\n  }\n\n  // ...and that this application has the correct number of arguments.\n  const actual = this.args.length;\n  const expected = ruleInfo.formals.length;\n  if (actual !== expected) {\n    throw errors.wrongNumberOfArguments(this.ruleName, expected, actual, this.source);\n  }\n\n  const isBuiltInApplySyntactic =\n    BuiltInRules && ruleInfo === BuiltInRules.rules.applySyntactic;\n  const isBuiltInCaseInsensitive =\n    BuiltInRules && ruleInfo === BuiltInRules.rules.caseInsensitive;\n\n  // If it's an application of 'caseInsensitive', ensure that the argument is a Terminal.\n  if (isBuiltInCaseInsensitive) {\n    if (!(this.args[0] instanceof pexprs.Terminal)) {\n      throw errors.incorrectArgumentType('a Terminal (e.g. \"abc\")', this.args[0]);\n    }\n  }\n\n  if (isBuiltInApplySyntactic) {\n    const arg = this.args[0];\n    if (!(arg instanceof pexprs.Apply)) {\n      throw errors.incorrectArgumentType('a syntactic rule application', arg);\n    }\n    if (!isSyntactic(arg.ruleName)) {\n      throw errors.applySyntacticWithLexicalRuleApplication(arg);\n    }\n    if (isContextSyntactic) {\n      throw errors.unnecessaryExperimentalApplySyntactic(this);\n    }\n  }\n\n  // ...and that all of the argument expressions only have valid applications and have arity 1.\n  // If `this` is an application of the built-in applySyntactic rule, then its arg is\n  // allowed (and expected) to be a syntactic rule, even if we're in a lexical context.\n  this.args.forEach(arg => {\n    arg._assertAllApplicationsAreValid(ruleName, grammar, isBuiltInApplySyntactic);\n    if (arg.getArity() !== 1) {\n      throw errors.invalidParameter(this.ruleName, arg);\n    }\n  });\n};\n","import {abstract} from './common.js';\nimport * as errors from './errors.js';\nimport * as pexprs from './pexprs-main.js';\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs.PExpr.prototype.assertChoicesHaveUniformArity = abstract(\n    'assertChoicesHaveUniformArity',\n);\n\npexprs.any.assertChoicesHaveUniformArity =\n  pexprs.end.assertChoicesHaveUniformArity =\n  pexprs.Terminal.prototype.assertChoicesHaveUniformArity =\n  pexprs.Range.prototype.assertChoicesHaveUniformArity =\n  pexprs.Param.prototype.assertChoicesHaveUniformArity =\n  pexprs.Lex.prototype.assertChoicesHaveUniformArity =\n  pexprs.UnicodeChar.prototype.assertChoicesHaveUniformArity =\n    function(ruleName) {\n      // no-op\n    };\n\npexprs.Alt.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  if (this.terms.length === 0) {\n    return;\n  }\n  const arity = this.terms[0].getArity();\n  for (let idx = 0; idx < this.terms.length; idx++) {\n    const term = this.terms[idx];\n    term.assertChoicesHaveUniformArity();\n    const otherArity = term.getArity();\n    if (arity !== otherArity) {\n      throw errors.inconsistentArity(ruleName, arity, otherArity, term);\n    }\n  }\n};\n\npexprs.Extend.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  // Extend is a special case of Alt that's guaranteed to have exactly two\n  // cases: [extensions, origBody].\n  const actualArity = this.terms[0].getArity();\n  const expectedArity = this.terms[1].getArity();\n  if (actualArity !== expectedArity) {\n    throw errors.inconsistentArity(ruleName, expectedArity, actualArity, this.terms[0]);\n  }\n};\n\npexprs.Seq.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  for (let idx = 0; idx < this.factors.length; idx++) {\n    this.factors[idx].assertChoicesHaveUniformArity(ruleName);\n  }\n};\n\npexprs.Iter.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  this.expr.assertChoicesHaveUniformArity(ruleName);\n};\n\npexprs.Not.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  // no-op (not required b/c the nested expr doesn't show up in the CST)\n};\n\npexprs.Lookahead.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  this.expr.assertChoicesHaveUniformArity(ruleName);\n};\n\npexprs.Apply.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  // The arities of the parameter expressions is required to be 1 by\n  // `assertAllApplicationsAreValid()`.\n};\n","import {abstract} from './common.js';\nimport * as errors from './errors.js';\nimport * as pexprs from './pexprs-main.js';\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs.PExpr.prototype.assertIteratedExprsAreNotNullable = abstract(\n    'assertIteratedExprsAreNotNullable',\n);\n\npexprs.any.assertIteratedExprsAreNotNullable =\n  pexprs.end.assertIteratedExprsAreNotNullable =\n  pexprs.Terminal.prototype.assertIteratedExprsAreNotNullable =\n  pexprs.Range.prototype.assertIteratedExprsAreNotNullable =\n  pexprs.Param.prototype.assertIteratedExprsAreNotNullable =\n  pexprs.UnicodeChar.prototype.assertIteratedExprsAreNotNullable =\n    function(grammar) {\n      // no-op\n    };\n\npexprs.Alt.prototype.assertIteratedExprsAreNotNullable = function(grammar) {\n  for (let idx = 0; idx < this.terms.length; idx++) {\n    this.terms[idx].assertIteratedExprsAreNotNullable(grammar);\n  }\n};\n\npexprs.Seq.prototype.assertIteratedExprsAreNotNullable = function(grammar) {\n  for (let idx = 0; idx < this.factors.length; idx++) {\n    this.factors[idx].assertIteratedExprsAreNotNullable(grammar);\n  }\n};\n\npexprs.Iter.prototype.assertIteratedExprsAreNotNullable = function(grammar) {\n  // Note: this is the implementation of this method for `Star` and `Plus` expressions.\n  // It is overridden for `Opt` below.\n  this.expr.assertIteratedExprsAreNotNullable(grammar);\n  if (this.expr.isNullable(grammar)) {\n    throw errors.kleeneExprHasNullableOperand(this, []);\n  }\n};\n\npexprs.Opt.prototype.assertIteratedExprsAreNotNullable =\n  pexprs.Not.prototype.assertIteratedExprsAreNotNullable =\n  pexprs.Lookahead.prototype.assertIteratedExprsAreNotNullable =\n  pexprs.Lex.prototype.assertIteratedExprsAreNotNullable =\n    function(grammar) {\n      this.expr.assertIteratedExprsAreNotNullable(grammar);\n    };\n\npexprs.Apply.prototype.assertIteratedExprsAreNotNullable = function(grammar) {\n  this.args.forEach(arg => {\n    arg.assertIteratedExprsAreNotNullable(grammar);\n  });\n};\n","import * as common from './common.js';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nexport class Node {\n  constructor(matchLength) {\n    this.matchLength = matchLength;\n  }\n\n  get ctorName() {\n    throw new Error('subclass responsibility');\n  }\n\n  numChildren() {\n    return this.children ? this.children.length : 0;\n  }\n\n  childAt(idx) {\n    if (this.children) {\n      return this.children[idx];\n    }\n  }\n\n  indexOfChild(arg) {\n    return this.children.indexOf(arg);\n  }\n\n  hasChildren() {\n    return this.numChildren() > 0;\n  }\n\n  hasNoChildren() {\n    return !this.hasChildren();\n  }\n\n  onlyChild() {\n    if (this.numChildren() !== 1) {\n      throw new Error(\n          'cannot get only child of a node of type ' +\n          this.ctorName +\n          ' (it has ' +\n          this.numChildren() +\n          ' children)',\n      );\n    } else {\n      return this.firstChild();\n    }\n  }\n\n  firstChild() {\n    if (this.hasNoChildren()) {\n      throw new Error(\n          'cannot get first child of a ' + this.ctorName + ' node, which has no children',\n      );\n    } else {\n      return this.childAt(0);\n    }\n  }\n\n  lastChild() {\n    if (this.hasNoChildren()) {\n      throw new Error(\n          'cannot get last child of a ' + this.ctorName + ' node, which has no children',\n      );\n    } else {\n      return this.childAt(this.numChildren() - 1);\n    }\n  }\n\n  childBefore(child) {\n    const childIdx = this.indexOfChild(child);\n    if (childIdx < 0) {\n      throw new Error('Node.childBefore() called w/ an argument that is not a child');\n    } else if (childIdx === 0) {\n      throw new Error('cannot get child before first child');\n    } else {\n      return this.childAt(childIdx - 1);\n    }\n  }\n\n  childAfter(child) {\n    const childIdx = this.indexOfChild(child);\n    if (childIdx < 0) {\n      throw new Error('Node.childAfter() called w/ an argument that is not a child');\n    } else if (childIdx === this.numChildren() - 1) {\n      throw new Error('cannot get child after last child');\n    } else {\n      return this.childAt(childIdx + 1);\n    }\n  }\n\n  isTerminal() {\n    return false;\n  }\n\n  isNonterminal() {\n    return false;\n  }\n\n  isIteration() {\n    return false;\n  }\n\n  isOptional() {\n    return false;\n  }\n}\n\n// Terminals\n\nexport class TerminalNode extends Node {\n  get ctorName() {\n    return '_terminal';\n  }\n\n  isTerminal() {\n    return true;\n  }\n\n  get primitiveValue() {\n    throw new Error('The `primitiveValue` property was removed in Ohm v17.');\n  }\n}\n\n// Nonterminals\n\nexport class NonterminalNode extends Node {\n  constructor(ruleName, children, childOffsets, matchLength) {\n    super(matchLength);\n    this.ruleName = ruleName;\n    this.children = children;\n    this.childOffsets = childOffsets;\n  }\n\n  get ctorName() {\n    return this.ruleName;\n  }\n\n  isNonterminal() {\n    return true;\n  }\n\n  isLexical() {\n    return common.isLexical(this.ctorName);\n  }\n\n  isSyntactic() {\n    return common.isSyntactic(this.ctorName);\n  }\n}\n\n// Iterations\n\nexport class IterationNode extends Node {\n  constructor(children, childOffsets, matchLength, isOptional) {\n    super(matchLength);\n    this.children = children;\n    this.childOffsets = childOffsets;\n    this.optional = isOptional;\n  }\n\n  get ctorName() {\n    return '_iter';\n  }\n\n  isIteration() {\n    return true;\n  }\n\n  isOptional() {\n    return this.optional;\n  }\n}\n","import {Trace} from './Trace.js';\nimport * as common from './common.js';\nimport * as errors from './errors.js';\nimport {IterationNode, NonterminalNode, TerminalNode} from './nodes.js';\nimport * as pexprs from './pexprs-main.js';\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  Evaluate the expression and return `true` if it succeeds, `false` otherwise. This method should\n  only be called directly by `State.prototype.eval(expr)`, which also updates the data structures\n  that are used for tracing. (Making those updates in a method of `State` enables the trace-specific\n  data structures to be \"secrets\" of that class, which is good for modularity.)\n\n  The contract of this method is as follows:\n  * When the return value is `true`,\n    - the state object will have `expr.getArity()` more bindings than it did before the call.\n  * When the return value is `false`,\n    - the state object may have more bindings than it did before the call, and\n    - its input stream's position may be anywhere.\n\n  Note that `State.prototype.eval(expr)`, unlike this method, guarantees that neither the state\n  object's bindings nor its input stream's position will change if the expression fails to match.\n*/\npexprs.PExpr.prototype.eval = common.abstract('eval'); // function(state) { ... }\n\npexprs.any.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  const cp = inputStream.nextCodePoint();\n  if (cp !== undefined) {\n    state.pushBinding(new TerminalNode(String.fromCodePoint(cp).length), origPos);\n    return true;\n  } else {\n    state.processFailure(origPos, this);\n    return false;\n  }\n};\n\npexprs.end.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  if (inputStream.atEnd()) {\n    state.pushBinding(new TerminalNode(0), origPos);\n    return true;\n  } else {\n    state.processFailure(origPos, this);\n    return false;\n  }\n};\n\npexprs.Terminal.prototype.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  if (!inputStream.matchString(this.obj)) {\n    state.processFailure(origPos, this);\n    return false;\n  } else {\n    state.pushBinding(new TerminalNode(this.obj.length), origPos);\n    return true;\n  }\n};\n\npexprs.Range.prototype.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n\n  // A range can operate in one of two modes: matching a single, 16-bit _code unit_,\n  // or matching a _code point_. (Code points over 0xFFFF take up two 16-bit code units.)\n  const cp = this.matchCodePoint ? inputStream.nextCodePoint() : inputStream.nextCharCode();\n\n  // Always compare by code point value to get the correct result in all scenarios.\n  // Note that for strings of length 1, codePointAt(0) and charPointAt(0) are equivalent.\n  if (cp !== undefined && this.from.codePointAt(0) <= cp && cp <= this.to.codePointAt(0)) {\n    state.pushBinding(new TerminalNode(String.fromCodePoint(cp).length), origPos);\n    return true;\n  } else {\n    state.processFailure(origPos, this);\n    return false;\n  }\n};\n\npexprs.Param.prototype.eval = function(state) {\n  return state.eval(state.currentApplication().args[this.index]);\n};\n\npexprs.Lex.prototype.eval = function(state) {\n  state.enterLexifiedContext();\n  const ans = state.eval(this.expr);\n  state.exitLexifiedContext();\n  return ans;\n};\n\npexprs.Alt.prototype.eval = function(state) {\n  for (let idx = 0; idx < this.terms.length; idx++) {\n    if (state.eval(this.terms[idx])) {\n      return true;\n    }\n  }\n  return false;\n};\n\npexprs.Seq.prototype.eval = function(state) {\n  for (let idx = 0; idx < this.factors.length; idx++) {\n    const factor = this.factors[idx];\n    if (!state.eval(factor)) {\n      return false;\n    }\n  }\n  return true;\n};\n\npexprs.Iter.prototype.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  const arity = this.getArity();\n  const cols = [];\n  const colOffsets = [];\n  while (cols.length < arity) {\n    cols.push([]);\n    colOffsets.push([]);\n  }\n\n  let numMatches = 0;\n  let prevPos = origPos;\n  let idx;\n  while (numMatches < this.maxNumMatches && state.eval(this.expr)) {\n    if (inputStream.pos === prevPos) {\n      throw errors.kleeneExprHasNullableOperand(this, state._applicationStack);\n    }\n    prevPos = inputStream.pos;\n    numMatches++;\n    const row = state._bindings.splice(state._bindings.length - arity, arity);\n    const rowOffsets = state._bindingOffsets.splice(\n        state._bindingOffsets.length - arity,\n        arity,\n    );\n    for (idx = 0; idx < row.length; idx++) {\n      cols[idx].push(row[idx]);\n      colOffsets[idx].push(rowOffsets[idx]);\n    }\n  }\n  if (numMatches < this.minNumMatches) {\n    return false;\n  }\n  let offset = state.posToOffset(origPos);\n  let matchLength = 0;\n  if (numMatches > 0) {\n    const lastCol = cols[arity - 1];\n    const lastColOffsets = colOffsets[arity - 1];\n\n    const endOffset =\n      lastColOffsets[lastColOffsets.length - 1] + lastCol[lastCol.length - 1].matchLength;\n    offset = colOffsets[0][0];\n    matchLength = endOffset - offset;\n  }\n  const isOptional = this instanceof pexprs.Opt;\n  for (idx = 0; idx < cols.length; idx++) {\n    state._bindings.push(\n        new IterationNode(cols[idx], colOffsets[idx], matchLength, isOptional),\n    );\n    state._bindingOffsets.push(offset);\n  }\n  return true;\n};\n\npexprs.Not.prototype.eval = function(state) {\n  /*\n    TODO:\n    - Right now we're just throwing away all of the failures that happen inside a `not`, and\n      recording `this` as a failed expression.\n    - Double negation should be equivalent to lookahead, but that's not the case right now wrt\n      failures. E.g., ~~'foo' produces a failure for ~~'foo', but maybe it should produce\n      a failure for 'foo' instead.\n  */\n\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  state.pushFailuresInfo();\n\n  const ans = state.eval(this.expr);\n\n  state.popFailuresInfo();\n  if (ans) {\n    state.processFailure(origPos, this);\n    return false;\n  }\n\n  inputStream.pos = origPos;\n  return true;\n};\n\npexprs.Lookahead.prototype.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  if (state.eval(this.expr)) {\n    inputStream.pos = origPos;\n    return true;\n  } else {\n    return false;\n  }\n};\n\npexprs.Apply.prototype.eval = function(state) {\n  const caller = state.currentApplication();\n  const actuals = caller ? caller.args : [];\n  const app = this.substituteParams(actuals);\n\n  const posInfo = state.getCurrentPosInfo();\n  if (posInfo.isActive(app)) {\n    // This rule is already active at this position, i.e., it is left-recursive.\n    return app.handleCycle(state);\n  }\n\n  const memoKey = app.toMemoKey();\n  const memoRec = posInfo.memo[memoKey];\n\n  if (memoRec && posInfo.shouldUseMemoizedResult(memoRec)) {\n    if (state.hasNecessaryInfo(memoRec)) {\n      return state.useMemoizedResult(state.inputStream.pos, memoRec);\n    }\n    delete posInfo.memo[memoKey];\n  }\n  return app.reallyEval(state);\n};\n\npexprs.Apply.prototype.handleCycle = function(state) {\n  const posInfo = state.getCurrentPosInfo();\n  const {currentLeftRecursion} = posInfo;\n  const memoKey = this.toMemoKey();\n  let memoRec = posInfo.memo[memoKey];\n\n  if (currentLeftRecursion && currentLeftRecursion.headApplication.toMemoKey() === memoKey) {\n    // We already know about this left recursion, but it's possible there are \"involved\n    // applications\" that we don't already know about, so...\n    memoRec.updateInvolvedApplicationMemoKeys();\n  } else if (!memoRec) {\n    // New left recursion detected! Memoize a failure to try to get a seed parse.\n    memoRec = posInfo.memoize(memoKey, {\n      matchLength: 0,\n      examinedLength: 0,\n      value: false,\n      rightmostFailureOffset: -1,\n    });\n    posInfo.startLeftRecursion(this, memoRec);\n  }\n  return state.useMemoizedResult(state.inputStream.pos, memoRec);\n};\n\npexprs.Apply.prototype.reallyEval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  const origPosInfo = state.getCurrentPosInfo();\n  const ruleInfo = state.grammar.rules[this.ruleName];\n  const {body} = ruleInfo;\n  const {description} = ruleInfo;\n\n  state.enterApplication(origPosInfo, this);\n\n  if (description) {\n    state.pushFailuresInfo();\n  }\n\n  // Reset the input stream's examinedLength property so that we can track\n  // the examined length of this particular application.\n  const origInputStreamExaminedLength = inputStream.examinedLength;\n  inputStream.examinedLength = 0;\n\n  let value = this.evalOnce(body, state);\n  const currentLR = origPosInfo.currentLeftRecursion;\n  const memoKey = this.toMemoKey();\n  const isHeadOfLeftRecursion = currentLR && currentLR.headApplication.toMemoKey() === memoKey;\n  let memoRec;\n\n  if (state.doNotMemoize) {\n    state.doNotMemoize = false;\n  } else if (isHeadOfLeftRecursion) {\n    value = this.growSeedResult(body, state, origPos, currentLR, value);\n    origPosInfo.endLeftRecursion();\n    memoRec = currentLR;\n    memoRec.examinedLength = inputStream.examinedLength - origPos;\n    memoRec.rightmostFailureOffset = state._getRightmostFailureOffset();\n    origPosInfo.memoize(memoKey, memoRec); // updates origPosInfo's maxExaminedLength\n  } else if (!currentLR || !currentLR.isInvolved(memoKey)) {\n    // This application is not involved in left recursion, so it's ok to memoize it.\n    memoRec = origPosInfo.memoize(memoKey, {\n      matchLength: inputStream.pos - origPos,\n      examinedLength: inputStream.examinedLength - origPos,\n      value,\n      failuresAtRightmostPosition: state.cloneRecordedFailures(),\n      rightmostFailureOffset: state._getRightmostFailureOffset(),\n    });\n  }\n  const succeeded = !!value;\n\n  if (description) {\n    state.popFailuresInfo();\n    if (!succeeded) {\n      state.processFailure(origPos, this);\n    }\n    if (memoRec) {\n      memoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();\n    }\n  }\n\n  // Record trace information in the memo table, so that it is available if the memoized result\n  // is used later.\n  if (state.isTracing() && memoRec) {\n    const entry = state.getTraceEntry(origPos, this, succeeded, succeeded ? [value] : []);\n    if (isHeadOfLeftRecursion) {\n      common.assert(entry.terminatingLREntry != null || !succeeded);\n      entry.isHeadOfLeftRecursion = true;\n    }\n    memoRec.traceEntry = entry;\n  }\n\n  // Fix the input stream's examinedLength -- it should be the maximum examined length\n  // across all applications, not just this one.\n  inputStream.examinedLength = Math.max(\n      inputStream.examinedLength,\n      origInputStreamExaminedLength,\n  );\n\n  state.exitApplication(origPosInfo, value);\n\n  return succeeded;\n};\n\npexprs.Apply.prototype.evalOnce = function(expr, state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n\n  if (state.eval(expr)) {\n    const arity = expr.getArity();\n    const bindings = state._bindings.splice(state._bindings.length - arity, arity);\n    const offsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);\n    const matchLength = inputStream.pos - origPos;\n    return new NonterminalNode(this.ruleName, bindings, offsets, matchLength);\n  } else {\n    return false;\n  }\n};\n\npexprs.Apply.prototype.growSeedResult = function(body, state, origPos, lrMemoRec, newValue) {\n  if (!newValue) {\n    return false;\n  }\n\n  const {inputStream} = state;\n\n  while (true) {\n    lrMemoRec.matchLength = inputStream.pos - origPos;\n    lrMemoRec.value = newValue;\n    lrMemoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();\n\n    if (state.isTracing()) {\n      // Before evaluating the body again, add a trace node for this application to the memo entry.\n      // Its only child is a copy of the trace node from `newValue`, which will always be the last\n      // element in `state.trace`.\n      const seedTrace = state.trace[state.trace.length - 1];\n      lrMemoRec.traceEntry = new Trace(\n          state.input,\n          origPos,\n          inputStream.pos,\n          this,\n          true,\n          [newValue],\n          [seedTrace.clone()],\n      );\n    }\n    inputStream.pos = origPos;\n    newValue = this.evalOnce(body, state);\n    if (inputStream.pos - origPos <= lrMemoRec.matchLength) {\n      break;\n    }\n    if (state.isTracing()) {\n      state.trace.splice(-2, 1); // Drop the trace for the old seed.\n    }\n  }\n  if (state.isTracing()) {\n    // The last entry is for an unused result -- pop it and save it in the \"real\" entry.\n    lrMemoRec.traceEntry.recordLRTermination(state.trace.pop(), newValue);\n  }\n  inputStream.pos = origPos + lrMemoRec.matchLength;\n  return lrMemoRec.value;\n};\n\npexprs.UnicodeChar.prototype.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  const ch = inputStream.next();\n  if (ch && this.pattern.test(ch)) {\n    state.pushBinding(new TerminalNode(ch.length), origPos);\n    return true;\n  } else {\n    state.processFailure(origPos, this);\n    return false;\n  }\n};\n","import {abstract} from './common.js';\nimport * as pexprs from './pexprs-main.js';\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs.PExpr.prototype.getArity = abstract('getArity');\n\npexprs.any.getArity =\n  pexprs.end.getArity =\n  pexprs.Terminal.prototype.getArity =\n  pexprs.Range.prototype.getArity =\n  pexprs.Param.prototype.getArity =\n  pexprs.Apply.prototype.getArity =\n  pexprs.UnicodeChar.prototype.getArity =\n    function() {\n      return 1;\n    };\n\npexprs.Alt.prototype.getArity = function() {\n  // This is ok b/c all terms must have the same arity -- this property is\n  // checked by the Grammar constructor.\n  return this.terms.length === 0 ? 0 : this.terms[0].getArity();\n};\n\npexprs.Seq.prototype.getArity = function() {\n  let arity = 0;\n  for (let idx = 0; idx < this.factors.length; idx++) {\n    arity += this.factors[idx].getArity();\n  }\n  return arity;\n};\n\npexprs.Iter.prototype.getArity = function() {\n  return this.expr.getArity();\n};\n\npexprs.Not.prototype.getArity = function() {\n  return 0;\n};\n\npexprs.Lookahead.prototype.getArity = pexprs.Lex.prototype.getArity = function() {\n  return this.expr.getArity();\n};\n","import {abstract} from './common.js';\nimport * as pexprs from './pexprs-main.js';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction getMetaInfo(expr, grammarInterval) {\n  const metaInfo = {};\n  if (expr.source && grammarInterval) {\n    const adjusted = expr.source.relativeTo(grammarInterval);\n    metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];\n  }\n  return metaInfo;\n}\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs.PExpr.prototype.outputRecipe = abstract('outputRecipe');\n\npexprs.any.outputRecipe = function(formals, grammarInterval) {\n  return ['any', getMetaInfo(this, grammarInterval)];\n};\n\npexprs.end.outputRecipe = function(formals, grammarInterval) {\n  return ['end', getMetaInfo(this, grammarInterval)];\n};\n\npexprs.Terminal.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['terminal', getMetaInfo(this, grammarInterval), this.obj];\n};\n\npexprs.Range.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['range', getMetaInfo(this, grammarInterval), this.from, this.to];\n};\n\npexprs.Param.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['param', getMetaInfo(this, grammarInterval), this.index];\n};\n\npexprs.Alt.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['alt', getMetaInfo(this, grammarInterval)].concat(\n      this.terms.map(term => term.outputRecipe(formals, grammarInterval)),\n  );\n};\n\npexprs.Extend.prototype.outputRecipe = function(formals, grammarInterval) {\n  const extension = this.terms[0]; // [extension, original]\n  return extension.outputRecipe(formals, grammarInterval);\n};\n\npexprs.Splice.prototype.outputRecipe = function(formals, grammarInterval) {\n  const beforeTerms = this.terms.slice(0, this.expansionPos);\n  const afterTerms = this.terms.slice(this.expansionPos + 1);\n  return [\n    'splice',\n    getMetaInfo(this, grammarInterval),\n    beforeTerms.map(term => term.outputRecipe(formals, grammarInterval)),\n    afterTerms.map(term => term.outputRecipe(formals, grammarInterval)),\n  ];\n};\n\npexprs.Seq.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['seq', getMetaInfo(this, grammarInterval)].concat(\n      this.factors.map(factor => factor.outputRecipe(formals, grammarInterval)),\n  );\n};\n\npexprs.Star.prototype.outputRecipe =\n  pexprs.Plus.prototype.outputRecipe =\n  pexprs.Opt.prototype.outputRecipe =\n  pexprs.Not.prototype.outputRecipe =\n  pexprs.Lookahead.prototype.outputRecipe =\n  pexprs.Lex.prototype.outputRecipe =\n    function(formals, grammarInterval) {\n      return [\n        this.constructor.name.toLowerCase(),\n        getMetaInfo(this, grammarInterval),\n        this.expr.outputRecipe(formals, grammarInterval),\n      ];\n    };\n\npexprs.Apply.prototype.outputRecipe = function(formals, grammarInterval) {\n  return [\n    'app',\n    getMetaInfo(this, grammarInterval),\n    this.ruleName,\n    this.args.map(arg => arg.outputRecipe(formals, grammarInterval)),\n  ];\n};\n\npexprs.UnicodeChar.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['unicodeChar', getMetaInfo(this, grammarInterval), this.category];\n};\n","import {abstract} from './common.js';\nimport * as pexprs from './pexprs-main.js';\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  Called at grammar creation time to rewrite a rule body, replacing each reference to a formal\n  parameter with a `Param` node. Returns a PExpr -- either a new one, or the original one if\n  it was modified in place.\n*/\npexprs.PExpr.prototype.introduceParams = abstract('introduceParams');\n\npexprs.any.introduceParams =\n  pexprs.end.introduceParams =\n  pexprs.Terminal.prototype.introduceParams =\n  pexprs.Range.prototype.introduceParams =\n  pexprs.Param.prototype.introduceParams =\n  pexprs.UnicodeChar.prototype.introduceParams =\n    function(formals) {\n      return this;\n    };\n\npexprs.Alt.prototype.introduceParams = function(formals) {\n  this.terms.forEach((term, idx, terms) => {\n    terms[idx] = term.introduceParams(formals);\n  });\n  return this;\n};\n\npexprs.Seq.prototype.introduceParams = function(formals) {\n  this.factors.forEach((factor, idx, factors) => {\n    factors[idx] = factor.introduceParams(formals);\n  });\n  return this;\n};\n\npexprs.Iter.prototype.introduceParams =\n  pexprs.Not.prototype.introduceParams =\n  pexprs.Lookahead.prototype.introduceParams =\n  pexprs.Lex.prototype.introduceParams =\n    function(formals) {\n      this.expr = this.expr.introduceParams(formals);\n      return this;\n    };\n\npexprs.Apply.prototype.introduceParams = function(formals) {\n  const index = formals.indexOf(this.ruleName);\n  if (index >= 0) {\n    if (this.args.length > 0) {\n      // TODO: Should this be supported? See issue #64.\n      throw new Error('Parameterized rules cannot be passed as arguments to another rule.');\n    }\n    return new pexprs.Param(index).withSource(this.source);\n  } else {\n    this.args.forEach((arg, idx, args) => {\n      args[idx] = arg.introduceParams(formals);\n    });\n    return this;\n  }\n};\n","import {abstract} from './common.js';\nimport * as pexprs from './pexprs-main.js';\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n// Returns `true` if this parsing expression may accept without consuming any input.\npexprs.PExpr.prototype.isNullable = function(grammar) {\n  return this._isNullable(grammar, Object.create(null));\n};\n\npexprs.PExpr.prototype._isNullable = abstract('_isNullable');\n\npexprs.any._isNullable =\n  pexprs.Range.prototype._isNullable =\n  pexprs.Param.prototype._isNullable =\n  pexprs.Plus.prototype._isNullable =\n  pexprs.UnicodeChar.prototype._isNullable =\n    function(grammar, memo) {\n      return false;\n    };\n\npexprs.end._isNullable = function(grammar, memo) {\n  return true;\n};\n\npexprs.Terminal.prototype._isNullable = function(grammar, memo) {\n  if (typeof this.obj === 'string') {\n    // This is an over-simplification: it's only correct if the input is a string. If it's an array\n    // or an object, then the empty string parsing expression is not nullable.\n    return this.obj === '';\n  } else {\n    return false;\n  }\n};\n\npexprs.Alt.prototype._isNullable = function(grammar, memo) {\n  return this.terms.length === 0 || this.terms.some(term => term._isNullable(grammar, memo));\n};\n\npexprs.Seq.prototype._isNullable = function(grammar, memo) {\n  return this.factors.every(factor => factor._isNullable(grammar, memo));\n};\n\npexprs.Star.prototype._isNullable =\n  pexprs.Opt.prototype._isNullable =\n  pexprs.Not.prototype._isNullable =\n  pexprs.Lookahead.prototype._isNullable =\n    function(grammar, memo) {\n      return true;\n    };\n\npexprs.Lex.prototype._isNullable = function(grammar, memo) {\n  return this.expr._isNullable(grammar, memo);\n};\n\npexprs.Apply.prototype._isNullable = function(grammar, memo) {\n  const key = this.toMemoKey();\n  if (!Object.prototype.hasOwnProperty.call(memo, key)) {\n    const {body} = grammar.rules[this.ruleName];\n    const inlined = body.substituteParams(this.args);\n    memo[key] = false; // Prevent infinite recursion for recursive rules.\n    memo[key] = inlined._isNullable(grammar, memo);\n  }\n  return memo[key];\n};\n","import {abstract, checkNotNull} from './common.js';\nimport * as pexprs from './pexprs-main.js';\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  Returns a PExpr that results from recursively replacing every formal parameter (i.e., instance\n  of `Param`) inside this PExpr with its actual value from `actuals` (an Array).\n\n  The receiver must not be modified; a new PExpr must be returned if any replacement is necessary.\n*/\n// function(actuals) { ... }\npexprs.PExpr.prototype.substituteParams = abstract('substituteParams');\n\npexprs.any.substituteParams =\n  pexprs.end.substituteParams =\n  pexprs.Terminal.prototype.substituteParams =\n  pexprs.Range.prototype.substituteParams =\n  pexprs.UnicodeChar.prototype.substituteParams =\n    function(actuals) {\n      return this;\n    };\n\npexprs.Param.prototype.substituteParams = function(actuals) {\n  return checkNotNull(actuals[this.index]);\n};\n\npexprs.Alt.prototype.substituteParams = function(actuals) {\n  return new pexprs.Alt(this.terms.map(term => term.substituteParams(actuals)));\n};\n\npexprs.Seq.prototype.substituteParams = function(actuals) {\n  return new pexprs.Seq(this.factors.map(factor => factor.substituteParams(actuals)));\n};\n\npexprs.Iter.prototype.substituteParams =\n  pexprs.Not.prototype.substituteParams =\n  pexprs.Lookahead.prototype.substituteParams =\n  pexprs.Lex.prototype.substituteParams =\n    function(actuals) {\n      return new this.constructor(this.expr.substituteParams(actuals));\n    };\n\npexprs.Apply.prototype.substituteParams = function(actuals) {\n  if (this.args.length === 0) {\n    // Avoid making a copy of this application, as an optimization\n    return this;\n  } else {\n    const args = this.args.map(arg => arg.substituteParams(actuals));\n    return new pexprs.Apply(this.ruleName, args);\n  }\n};\n","import {abstract, copyWithoutDuplicates} from './common.js';\nimport * as pexprs from './pexprs-main.js';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction isRestrictedJSIdentifier(str) {\n  return /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(str);\n}\n\nfunction resolveDuplicatedNames(argumentNameList) {\n  // `count` is used to record the number of times each argument name occurs in the list,\n  // this is useful for checking duplicated argument name. It maps argument names to ints.\n  const count = Object.create(null);\n  argumentNameList.forEach(argName => {\n    count[argName] = (count[argName] || 0) + 1;\n  });\n\n  // Append subscripts ('_1', '_2', ...) to duplicate argument names.\n  Object.keys(count).forEach(dupArgName => {\n    if (count[dupArgName] <= 1) {\n      return;\n    }\n\n    // This name shows up more than once, so add subscripts.\n    let subscript = 1;\n    argumentNameList.forEach((argName, idx) => {\n      if (argName === dupArgName) {\n        argumentNameList[idx] = argName + '_' + subscript++;\n      }\n    });\n  });\n}\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  Returns a list of strings that will be used as the default argument names for its receiver\n  (a pexpr) in a semantic action. This is used exclusively by the Semantics Editor.\n\n  `firstArgIndex` is the 1-based index of the first argument name that will be generated for this\n  pexpr. It enables us to name arguments positionally, e.g., if the second argument is a\n  non-alphanumeric terminal like \"+\", it will be named '$2'.\n\n  `noDupCheck` is true if the caller of `toArgumentNameList` is not a top level caller. It enables\n  us to avoid nested duplication subscripts appending, e.g., '_1_1', '_1_2', by only checking\n  duplicates at the top level.\n\n  Here is a more elaborate example that illustrates how this method works:\n  `(a \"+\" b).toArgumentNameList(1)` evaluates to `['a', '$2', 'b']` with the following recursive\n  calls:\n\n    (a).toArgumentNameList(1) -> ['a'],\n    (\"+\").toArgumentNameList(2) -> ['$2'],\n    (b).toArgumentNameList(3) -> ['b']\n\n  Notes:\n  * This method must only be called on well-formed expressions, e.g., the receiver must\n    not have any Alt sub-expressions with inconsistent arities.\n  * e.getArity() === e.toArgumentNameList(1).length\n*/\n// function(firstArgIndex, noDupCheck) { ... }\npexprs.PExpr.prototype.toArgumentNameList = abstract('toArgumentNameList');\n\npexprs.any.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return ['any'];\n};\n\npexprs.end.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return ['end'];\n};\n\npexprs.Terminal.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  if (typeof this.obj === 'string' && /^[_a-zA-Z0-9]+$/.test(this.obj)) {\n    // If this terminal is a valid suffix for a JS identifier, just prepend it with '_'\n    return ['_' + this.obj];\n  } else {\n    // Otherwise, name it positionally.\n    return ['$' + firstArgIndex];\n  }\n};\n\npexprs.Range.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  let argName = this.from + '_to_' + this.to;\n  // If the `argName` is not valid then try to prepend a `_`.\n  if (!isRestrictedJSIdentifier(argName)) {\n    argName = '_' + argName;\n  }\n  // If the `argName` still not valid after prepending a `_`, then name it positionally.\n  if (!isRestrictedJSIdentifier(argName)) {\n    argName = '$' + firstArgIndex;\n  }\n  return [argName];\n};\n\npexprs.Alt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  // `termArgNameLists` is an array of arrays where each row is the\n  // argument name list that corresponds to a term in this alternation.\n  const termArgNameLists = this.terms.map(term =>\n    term.toArgumentNameList(firstArgIndex, true),\n  );\n\n  const argumentNameList = [];\n  const numArgs = termArgNameLists[0].length;\n  for (let colIdx = 0; colIdx < numArgs; colIdx++) {\n    const col = [];\n    for (let rowIdx = 0; rowIdx < this.terms.length; rowIdx++) {\n      col.push(termArgNameLists[rowIdx][colIdx]);\n    }\n    const uniqueNames = copyWithoutDuplicates(col);\n    argumentNameList.push(uniqueNames.join('_or_'));\n  }\n\n  if (!noDupCheck) {\n    resolveDuplicatedNames(argumentNameList);\n  }\n  return argumentNameList;\n};\n\npexprs.Seq.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  // Generate the argument name list, without worrying about duplicates.\n  let argumentNameList = [];\n  this.factors.forEach(factor => {\n    const factorArgumentNameList = factor.toArgumentNameList(firstArgIndex, true);\n    argumentNameList = argumentNameList.concat(factorArgumentNameList);\n\n    // Shift the firstArgIndex to take this factor's argument names into account.\n    firstArgIndex += factorArgumentNameList.length;\n  });\n  if (!noDupCheck) {\n    resolveDuplicatedNames(argumentNameList);\n  }\n  return argumentNameList;\n};\n\npexprs.Iter.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  const argumentNameList = this.expr\n      .toArgumentNameList(firstArgIndex, noDupCheck)\n      .map(exprArgumentString =>\n      exprArgumentString[exprArgumentString.length - 1] === 's' ?\n        exprArgumentString + 'es' :\n        exprArgumentString + 's',\n      );\n  if (!noDupCheck) {\n    resolveDuplicatedNames(argumentNameList);\n  }\n  return argumentNameList;\n};\n\npexprs.Opt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map(argName => {\n    return 'opt' + argName[0].toUpperCase() + argName.slice(1);\n  });\n};\n\npexprs.Not.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return [];\n};\n\npexprs.Lookahead.prototype.toArgumentNameList = pexprs.Lex.prototype.toArgumentNameList =\n  function(firstArgIndex, noDupCheck) {\n    return this.expr.toArgumentNameList(firstArgIndex, noDupCheck);\n  };\n\npexprs.Apply.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return [this.ruleName];\n};\n\npexprs.UnicodeChar.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return ['$' + firstArgIndex];\n};\n\npexprs.Param.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return ['param' + this.index];\n};\n\n// \"Value pexprs\" (Value, Str, Arr, Obj) are going away soon, so we don't worry about them here.\n","import {abstract} from './common.js';\nimport * as pexprs from './pexprs-main.js';\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n// Returns a string representing the PExpr, for use as a UI label, etc.\npexprs.PExpr.prototype.toDisplayString = abstract('toDisplayString');\n\npexprs.Alt.prototype.toDisplayString = pexprs.Seq.prototype.toDisplayString = function() {\n  if (this.source) {\n    return this.source.trimmed().contents;\n  }\n  return '[' + this.constructor.name + ']';\n};\n\npexprs.any.toDisplayString =\n  pexprs.end.toDisplayString =\n  pexprs.Iter.prototype.toDisplayString =\n  pexprs.Not.prototype.toDisplayString =\n  pexprs.Lookahead.prototype.toDisplayString =\n  pexprs.Lex.prototype.toDisplayString =\n  pexprs.Terminal.prototype.toDisplayString =\n  pexprs.Range.prototype.toDisplayString =\n  pexprs.Param.prototype.toDisplayString =\n    function() {\n      return this.toString();\n    };\n\npexprs.Apply.prototype.toDisplayString = function() {\n  if (this.args.length > 0) {\n    const ps = this.args.map(arg => arg.toDisplayString());\n    return this.ruleName + '<' + ps.join(',') + '>';\n  } else {\n    return this.ruleName;\n  }\n};\n\npexprs.UnicodeChar.prototype.toDisplayString = function() {\n  return 'Unicode [' + this.category + '] character';\n};\n","// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n/*\n  `Failure`s represent expressions that weren't matched while parsing. They are used to generate\n  error messages automatically. The interface of `Failure`s includes the collowing methods:\n\n  - getText() : String\n  - getType() : String  (one of {\"description\", \"string\", \"code\"})\n  - isDescription() : bool\n  - isStringTerminal() : bool\n  - isCode() : bool\n  - isFluffy() : bool\n  - makeFluffy() : void\n  - subsumes(Failure) : bool\n*/\n\nfunction isValidType(type) {\n  return type === 'description' || type === 'string' || type === 'code';\n}\n\nexport class Failure {\n  constructor(pexpr, text, type) {\n    if (!isValidType(type)) {\n      throw new Error('invalid Failure type: ' + type);\n    }\n    this.pexpr = pexpr;\n    this.text = text;\n    this.type = type;\n    this.fluffy = false;\n  }\n\n  getPExpr() {\n    return this.pexpr;\n  }\n\n  getText() {\n    return this.text;\n  }\n\n  getType() {\n    return this.type;\n  }\n\n  isDescription() {\n    return this.type === 'description';\n  }\n\n  isStringTerminal() {\n    return this.type === 'string';\n  }\n\n  isCode() {\n    return this.type === 'code';\n  }\n\n  isFluffy() {\n    return this.fluffy;\n  }\n\n  makeFluffy() {\n    this.fluffy = true;\n  }\n\n  clearFluffy() {\n    this.fluffy = false;\n  }\n\n  subsumes(that) {\n    return (\n      this.getText() === that.getText() &&\n      this.type === that.type &&\n      (!this.isFluffy() || (this.isFluffy() && that.isFluffy()))\n    );\n  }\n\n  toString() {\n    return this.type === 'string' ? JSON.stringify(this.getText()) : this.getText();\n  }\n\n  clone() {\n    const failure = new Failure(this.pexpr, this.text, this.type);\n    if (this.isFluffy()) {\n      failure.makeFluffy();\n    }\n    return failure;\n  }\n\n  toKey() {\n    return this.toString() + '#' + this.type;\n  }\n}\n","import {abstract} from './common.js';\nimport * as pexprs from './pexprs-main.js';\nimport {Failure} from './Failure.js';\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs.PExpr.prototype.toFailure = abstract('toFailure');\n\npexprs.any.toFailure = function(grammar) {\n  return new Failure(this, 'any object', 'description');\n};\n\npexprs.end.toFailure = function(grammar) {\n  return new Failure(this, 'end of input', 'description');\n};\n\npexprs.Terminal.prototype.toFailure = function(grammar) {\n  return new Failure(this, this.obj, 'string');\n};\n\npexprs.Range.prototype.toFailure = function(grammar) {\n  // TODO: come up with something better\n  return new Failure(this, JSON.stringify(this.from) + '..' + JSON.stringify(this.to), 'code');\n};\n\npexprs.Not.prototype.toFailure = function(grammar) {\n  const description =\n    this.expr === pexprs.any ? 'nothing' : 'not ' + this.expr.toFailure(grammar);\n  return new Failure(this, description, 'description');\n};\n\npexprs.Lookahead.prototype.toFailure = function(grammar) {\n  return this.expr.toFailure(grammar);\n};\n\npexprs.Apply.prototype.toFailure = function(grammar) {\n  let {description} = grammar.rules[this.ruleName];\n  if (!description) {\n    const article = /^[aeiouAEIOU]/.test(this.ruleName) ? 'an' : 'a';\n    description = article + ' ' + this.ruleName;\n  }\n  return new Failure(this, description, 'description');\n};\n\npexprs.UnicodeChar.prototype.toFailure = function(grammar) {\n  return new Failure(this, 'a Unicode [' + this.category + '] character', 'description');\n};\n\npexprs.Alt.prototype.toFailure = function(grammar) {\n  const fs = this.terms.map(t => t.toFailure(grammar));\n  const description = '(' + fs.join(' or ') + ')';\n  return new Failure(this, description, 'description');\n};\n\npexprs.Seq.prototype.toFailure = function(grammar) {\n  const fs = this.factors.map(f => f.toFailure(grammar));\n  const description = '(' + fs.join(' ') + ')';\n  return new Failure(this, description, 'description');\n};\n\npexprs.Iter.prototype.toFailure = function(grammar) {\n  const description = '(' + this.expr.toFailure(grammar) + this.operator + ')';\n  return new Failure(this, description, 'description');\n};\n","import {abstract} from './common.js';\nimport * as pexprs from './pexprs-main.js';\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  e1.toString() === e2.toString() ==> e1 and e2 are semantically equivalent.\n  Note that this is not an iff (<==>): e.g.,\n  (~\"b\" \"a\").toString() !== (\"a\").toString(), even though\n  ~\"b\" \"a\" and \"a\" are interchangeable in any grammar,\n  both in terms of the languages they accept and their arities.\n*/\npexprs.PExpr.prototype.toString = abstract('toString');\n\npexprs.any.toString = function() {\n  return 'any';\n};\n\npexprs.end.toString = function() {\n  return 'end';\n};\n\npexprs.Terminal.prototype.toString = function() {\n  return JSON.stringify(this.obj);\n};\n\npexprs.Range.prototype.toString = function() {\n  return JSON.stringify(this.from) + '..' + JSON.stringify(this.to);\n};\n\npexprs.Param.prototype.toString = function() {\n  return '$' + this.index;\n};\n\npexprs.Lex.prototype.toString = function() {\n  return '#(' + this.expr.toString() + ')';\n};\n\npexprs.Alt.prototype.toString = function() {\n  return this.terms.length === 1 ?\n    this.terms[0].toString() :\n    '(' + this.terms.map(term => term.toString()).join(' | ') + ')';\n};\n\npexprs.Seq.prototype.toString = function() {\n  return this.factors.length === 1 ?\n    this.factors[0].toString() :\n    '(' + this.factors.map(factor => factor.toString()).join(' ') + ')';\n};\n\npexprs.Iter.prototype.toString = function() {\n  return this.expr + this.operator;\n};\n\npexprs.Not.prototype.toString = function() {\n  return '~' + this.expr;\n};\n\npexprs.Lookahead.prototype.toString = function() {\n  return '&' + this.expr;\n};\n\npexprs.Apply.prototype.toString = function() {\n  if (this.args.length > 0) {\n    const ps = this.args.map(arg => arg.toString());\n    return this.ruleName + '<' + ps.join(',') + '>';\n  } else {\n    return this.ruleName;\n  }\n};\n\npexprs.UnicodeChar.prototype.toString = function() {\n  return '\\\\p{' + this.category + '}';\n};\n","import {Failure} from './Failure.js';\nimport {TerminalNode} from './nodes.js';\nimport {assert} from './common.js';\nimport {PExpr, Terminal} from './pexprs-main.js';\n\nexport class CaseInsensitiveTerminal extends PExpr {\n  constructor(param) {\n    super();\n    this.obj = param;\n  }\n\n  _getString(state) {\n    const terminal = state.currentApplication().args[this.obj.index];\n    assert(terminal instanceof Terminal, 'expected a Terminal expression');\n    return terminal.obj;\n  }\n\n  // Implementation of the PExpr API\n\n  allowsSkippingPrecedingSpace() {\n    return true;\n  }\n\n  eval(state) {\n    const {inputStream} = state;\n    const origPos = inputStream.pos;\n    const matchStr = this._getString(state);\n    if (!inputStream.matchString(matchStr, true)) {\n      state.processFailure(origPos, this);\n      return false;\n    } else {\n      state.pushBinding(new TerminalNode(matchStr.length), origPos);\n      return true;\n    }\n  }\n\n  getArity() {\n    return 1;\n  }\n\n  substituteParams(actuals) {\n    return new CaseInsensitiveTerminal(this.obj.substituteParams(actuals));\n  }\n\n  toDisplayString() {\n    return this.obj.toDisplayString() + ' (case-insensitive)';\n  }\n\n  toFailure(grammar) {\n    return new Failure(\n        this,\n        this.obj.toFailure(grammar) + ' (case-insensitive)',\n        'description',\n    );\n  }\n\n  _isNullable(grammar, memo) {\n    return this.obj._isNullable(grammar, memo);\n  }\n}\n","import {InputStream} from './InputStream.js';\nimport {MatchResult} from './MatchResult.js';\nimport {PosInfo} from './PosInfo.js';\nimport {Trace} from './Trace.js';\nimport * as pexprs from './pexprs.js';\nimport * as util from './util.js';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nlet builtInApplySyntacticBody;\n\nutil.awaitBuiltInRules(builtInRules => {\n  builtInApplySyntacticBody = builtInRules.rules.applySyntactic.body;\n});\n\nconst applySpaces = new pexprs.Apply('spaces');\n\nexport class MatchState {\n  constructor(matcher, startExpr, optPositionToRecordFailures) {\n    this.matcher = matcher;\n    this.startExpr = startExpr;\n\n    this.grammar = matcher.grammar;\n    this.input = matcher.getInput();\n    this.inputStream = new InputStream(this.input);\n    this.memoTable = matcher._memoTable;\n\n    this.userData = undefined;\n    this.doNotMemoize = false;\n\n    this._bindings = [];\n    this._bindingOffsets = [];\n    this._applicationStack = [];\n    this._posStack = [0];\n    this.inLexifiedContextStack = [false];\n\n    this.rightmostFailurePosition = -1;\n    this._rightmostFailurePositionStack = [];\n    this._recordedFailuresStack = [];\n\n    if (optPositionToRecordFailures !== undefined) {\n      this.positionToRecordFailures = optPositionToRecordFailures;\n      this.recordedFailures = Object.create(null);\n    }\n  }\n\n  posToOffset(pos) {\n    return pos - this._posStack[this._posStack.length - 1];\n  }\n\n  enterApplication(posInfo, app) {\n    this._posStack.push(this.inputStream.pos);\n    this._applicationStack.push(app);\n    this.inLexifiedContextStack.push(false);\n    posInfo.enter(app);\n    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);\n    this.rightmostFailurePosition = -1;\n  }\n\n  exitApplication(posInfo, optNode) {\n    const origPos = this._posStack.pop();\n    this._applicationStack.pop();\n    this.inLexifiedContextStack.pop();\n    posInfo.exit();\n\n    this.rightmostFailurePosition = Math.max(\n        this.rightmostFailurePosition,\n        this._rightmostFailurePositionStack.pop(),\n    );\n\n    if (optNode) {\n      this.pushBinding(optNode, origPos);\n    }\n  }\n\n  enterLexifiedContext() {\n    this.inLexifiedContextStack.push(true);\n  }\n\n  exitLexifiedContext() {\n    this.inLexifiedContextStack.pop();\n  }\n\n  currentApplication() {\n    return this._applicationStack[this._applicationStack.length - 1];\n  }\n\n  inSyntacticContext() {\n    const currentApplication = this.currentApplication();\n    if (currentApplication) {\n      return currentApplication.isSyntactic() && !this.inLexifiedContext();\n    } else {\n      // The top-level context is syntactic if the start application is.\n      return this.startExpr.factors[0].isSyntactic();\n    }\n  }\n\n  inLexifiedContext() {\n    return this.inLexifiedContextStack[this.inLexifiedContextStack.length - 1];\n  }\n\n  skipSpaces() {\n    this.pushFailuresInfo();\n    this.eval(applySpaces);\n    this.popBinding();\n    this.popFailuresInfo();\n    return this.inputStream.pos;\n  }\n\n  skipSpacesIfInSyntacticContext() {\n    return this.inSyntacticContext() ? this.skipSpaces() : this.inputStream.pos;\n  }\n\n  maybeSkipSpacesBefore(expr) {\n    if (expr.allowsSkippingPrecedingSpace() && expr !== applySpaces) {\n      return this.skipSpacesIfInSyntacticContext();\n    } else {\n      return this.inputStream.pos;\n    }\n  }\n\n  pushBinding(node, origPos) {\n    this._bindings.push(node);\n    this._bindingOffsets.push(this.posToOffset(origPos));\n  }\n\n  popBinding() {\n    this._bindings.pop();\n    this._bindingOffsets.pop();\n  }\n\n  numBindings() {\n    return this._bindings.length;\n  }\n\n  truncateBindings(newLength) {\n    // Yes, this is this really faster than setting the `length` property (tested with\n    // bin/es5bench on Node v6.1.0).\n    // Update 2021-10-25: still true on v14.15.5 — it's ~20% speedup on es5bench.\n    while (this._bindings.length > newLength) {\n      this.popBinding();\n    }\n  }\n\n  getCurrentPosInfo() {\n    return this.getPosInfo(this.inputStream.pos);\n  }\n\n  getPosInfo(pos) {\n    let posInfo = this.memoTable[pos];\n    if (!posInfo) {\n      posInfo = this.memoTable[pos] = new PosInfo();\n    }\n    return posInfo;\n  }\n\n  processFailure(pos, expr) {\n    this.rightmostFailurePosition = Math.max(this.rightmostFailurePosition, pos);\n\n    if (this.recordedFailures && pos === this.positionToRecordFailures) {\n      const app = this.currentApplication();\n      if (app) {\n        // Substitute parameters with the actual pexprs that were passed to\n        // the current rule.\n        expr = expr.substituteParams(app.args);\n      } else {\n        // This branch is only reached for the \"end-check\" that is\n        // performed after the top-level application. In that case,\n        // expr === pexprs.end so there is no need to substitute\n        // parameters.\n      }\n\n      this.recordFailure(expr.toFailure(this.grammar), false);\n    }\n  }\n\n  recordFailure(failure, shouldCloneIfNew) {\n    const key = failure.toKey();\n    if (!this.recordedFailures[key]) {\n      this.recordedFailures[key] = shouldCloneIfNew ? failure.clone() : failure;\n    } else if (this.recordedFailures[key].isFluffy() && !failure.isFluffy()) {\n      this.recordedFailures[key].clearFluffy();\n    }\n  }\n\n  recordFailures(failures, shouldCloneIfNew) {\n    Object.keys(failures).forEach(key => {\n      this.recordFailure(failures[key], shouldCloneIfNew);\n    });\n  }\n\n  cloneRecordedFailures() {\n    if (!this.recordedFailures) {\n      return undefined;\n    }\n\n    const ans = Object.create(null);\n    Object.keys(this.recordedFailures).forEach(key => {\n      ans[key] = this.recordedFailures[key].clone();\n    });\n    return ans;\n  }\n\n  getRightmostFailurePosition() {\n    return this.rightmostFailurePosition;\n  }\n\n  _getRightmostFailureOffset() {\n    return this.rightmostFailurePosition >= 0 ?\n      this.posToOffset(this.rightmostFailurePosition) :\n      -1;\n  }\n\n  // Returns the memoized trace entry for `expr` at `pos`, if one exists, `null` otherwise.\n  getMemoizedTraceEntry(pos, expr) {\n    const posInfo = this.memoTable[pos];\n    if (posInfo && expr instanceof pexprs.Apply) {\n      const memoRec = posInfo.memo[expr.toMemoKey()];\n      if (memoRec && memoRec.traceEntry) {\n        const entry = memoRec.traceEntry.cloneWithExpr(expr);\n        entry.isMemoized = true;\n        return entry;\n      }\n    }\n    return null;\n  }\n\n  // Returns a new trace entry, with the currently active trace array as its children.\n  getTraceEntry(pos, expr, succeeded, bindings) {\n    if (expr instanceof pexprs.Apply) {\n      const app = this.currentApplication();\n      const actuals = app ? app.args : [];\n      expr = expr.substituteParams(actuals);\n    }\n    return (\n      this.getMemoizedTraceEntry(pos, expr) ||\n      new Trace(this.input, pos, this.inputStream.pos, expr, succeeded, bindings, this.trace)\n    );\n  }\n\n  isTracing() {\n    return !!this.trace;\n  }\n\n  hasNecessaryInfo(memoRec) {\n    if (this.trace && !memoRec.traceEntry) {\n      return false;\n    }\n\n    if (\n      this.recordedFailures &&\n      this.inputStream.pos + memoRec.rightmostFailureOffset === this.positionToRecordFailures\n    ) {\n      return !!memoRec.failuresAtRightmostPosition;\n    }\n\n    return true;\n  }\n\n  useMemoizedResult(origPos, memoRec) {\n    if (this.trace) {\n      this.trace.push(memoRec.traceEntry);\n    }\n\n    const memoRecRightmostFailurePosition =\n      this.inputStream.pos + memoRec.rightmostFailureOffset;\n    this.rightmostFailurePosition = Math.max(\n        this.rightmostFailurePosition,\n        memoRecRightmostFailurePosition,\n    );\n    if (\n      this.recordedFailures &&\n      this.positionToRecordFailures === memoRecRightmostFailurePosition &&\n      memoRec.failuresAtRightmostPosition\n    ) {\n      this.recordFailures(memoRec.failuresAtRightmostPosition, true);\n    }\n\n    this.inputStream.examinedLength = Math.max(\n        this.inputStream.examinedLength,\n        memoRec.examinedLength + origPos,\n    );\n\n    if (memoRec.value) {\n      this.inputStream.pos += memoRec.matchLength;\n      this.pushBinding(memoRec.value, origPos);\n      return true;\n    }\n    return false;\n  }\n\n  // Evaluate `expr` and return `true` if it succeeded, `false` otherwise. On success, `bindings`\n  // will have `expr.getArity()` more elements than before, and the input stream's position may\n  // have increased. On failure, `bindings` and position will be unchanged.\n  eval(expr) {\n    const {inputStream} = this;\n    const origNumBindings = this._bindings.length;\n    const origUserData = this.userData;\n\n    let origRecordedFailures;\n    if (this.recordedFailures) {\n      origRecordedFailures = this.recordedFailures;\n      this.recordedFailures = Object.create(null);\n    }\n\n    const origPos = inputStream.pos;\n    const memoPos = this.maybeSkipSpacesBefore(expr);\n\n    let origTrace;\n    if (this.trace) {\n      origTrace = this.trace;\n      this.trace = [];\n    }\n\n    // Do the actual evaluation.\n    const ans = expr.eval(this);\n\n    if (this.trace) {\n      const bindings = this._bindings.slice(origNumBindings);\n      const traceEntry = this.getTraceEntry(memoPos, expr, ans, bindings);\n      traceEntry.isImplicitSpaces = expr === applySpaces;\n      traceEntry.isRootNode = expr === this.startExpr;\n      origTrace.push(traceEntry);\n      this.trace = origTrace;\n    }\n\n    if (ans) {\n      if (this.recordedFailures && inputStream.pos === this.positionToRecordFailures) {\n        Object.keys(this.recordedFailures).forEach(key => {\n          this.recordedFailures[key].makeFluffy();\n        });\n      }\n    } else {\n      // Reset the position, bindings, and userData.\n      inputStream.pos = origPos;\n      this.truncateBindings(origNumBindings);\n      this.userData = origUserData;\n    }\n\n    if (this.recordedFailures) {\n      this.recordFailures(origRecordedFailures, false);\n    }\n\n    // The built-in applySyntactic rule needs special handling: we want to skip\n    // trailing spaces, just as with the top-level application of a syntactic rule.\n    if (expr === builtInApplySyntacticBody) {\n      this.skipSpaces();\n    }\n\n    return ans;\n  }\n\n  getMatchResult() {\n    this.grammar._setUpMatchState(this);\n    this.eval(this.startExpr);\n    let rightmostFailures;\n    if (this.recordedFailures) {\n      rightmostFailures = Object.keys(this.recordedFailures).map(\n          key => this.recordedFailures[key],\n      );\n    }\n    const cst = this._bindings[0];\n    if (cst) {\n      cst.grammar = this.grammar;\n    }\n    return new MatchResult(\n        this.matcher,\n        this.input,\n        this.startExpr,\n        cst,\n        this._bindingOffsets[0],\n        this.rightmostFailurePosition,\n        rightmostFailures,\n    );\n  }\n\n  getTrace() {\n    this.trace = [];\n    const matchResult = this.getMatchResult();\n\n    // The trace node for the start rule is always the last entry. If it is a syntactic rule,\n    // the first entry is for an application of 'spaces'.\n    // TODO(pdubroy): Clean this up by introducing a special `Match<startAppl>` rule, which will\n    // ensure that there is always a single root trace node.\n    const rootTrace = this.trace[this.trace.length - 1];\n    rootTrace.result = matchResult;\n    return rootTrace;\n  }\n\n  pushFailuresInfo() {\n    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);\n    this._recordedFailuresStack.push(this.recordedFailures);\n  }\n\n  popFailuresInfo() {\n    this.rightmostFailurePosition = this._rightmostFailurePositionStack.pop();\n    this.recordedFailures = this._recordedFailuresStack.pop();\n  }\n}\n","import {grammarDoesNotSupportIncrementalParsing} from './errors.js';\nimport {MatchState} from './MatchState.js';\nimport * as pexprs from './pexprs.js';\n\nexport class Matcher {\n  constructor(grammar) {\n    this.grammar = grammar;\n    this._memoTable = [];\n    this._input = '';\n    this._isMemoTableStale = false;\n  }\n\n  _resetMemoTable() {\n    this._memoTable = [];\n    this._isMemoTableStale = false;\n  }\n\n  getInput() {\n    return this._input;\n  }\n\n  setInput(str) {\n    if (this._input !== str) {\n      this.replaceInputRange(0, this._input.length, str);\n    }\n    return this;\n  }\n\n  replaceInputRange(startIdx, endIdx, str) {\n    const prevInput = this._input;\n    const memoTable = this._memoTable;\n    if (\n      startIdx < 0 ||\n      startIdx > prevInput.length ||\n      endIdx < 0 ||\n      endIdx > prevInput.length ||\n      startIdx > endIdx\n    ) {\n      throw new Error('Invalid indices: ' + startIdx + ' and ' + endIdx);\n    }\n\n    // update input\n    this._input = prevInput.slice(0, startIdx) + str + prevInput.slice(endIdx);\n    if (this._input !== prevInput && memoTable.length > 0) {\n      this._isMemoTableStale = true;\n    }\n\n    // update memo table (similar to the above)\n    const restOfMemoTable = memoTable.slice(endIdx);\n    memoTable.length = startIdx;\n    for (let idx = 0; idx < str.length; idx++) {\n      memoTable.push(undefined);\n    }\n    for (const posInfo of restOfMemoTable) {\n      memoTable.push(posInfo);\n    }\n\n    // Invalidate memoRecs\n    for (let pos = 0; pos < startIdx; pos++) {\n      const posInfo = memoTable[pos];\n      if (posInfo) {\n        posInfo.clearObsoleteEntries(pos, startIdx);\n      }\n    }\n\n    return this;\n  }\n\n  match(optStartApplicationStr, options = {incremental: true}) {\n    return this._match(this._getStartExpr(optStartApplicationStr), {\n      incremental: options.incremental,\n      tracing: false,\n    });\n  }\n\n  trace(optStartApplicationStr, options = {incremental: true}) {\n    return this._match(this._getStartExpr(optStartApplicationStr), {\n      incremental: options.incremental,\n      tracing: true,\n    });\n  }\n\n  _match(startExpr, options = {}) {\n    const opts = {\n      tracing: false,\n      incremental: true,\n      positionToRecordFailures: undefined,\n      ...options,\n    };\n    if (!opts.incremental) {\n      this._resetMemoTable();\n    } else if (this._isMemoTableStale && !this.grammar.supportsIncrementalParsing) {\n      throw grammarDoesNotSupportIncrementalParsing(this.grammar);\n    }\n\n    const state = new MatchState(this, startExpr, opts.positionToRecordFailures);\n    return opts.tracing ? state.getTrace() : state.getMatchResult();\n  }\n\n  /*\n    Returns the starting expression for this Matcher's associated grammar. If\n    `optStartApplicationStr` is specified, it is a string expressing a rule application in the\n    grammar. If not specified, the grammar's default start rule will be used.\n  */\n  _getStartExpr(optStartApplicationStr) {\n    const applicationStr = optStartApplicationStr || this.grammar.defaultStartRule;\n    if (!applicationStr) {\n      throw new Error('Missing start rule argument -- the grammar has no default start rule.');\n    }\n\n    const startApp = this.grammar.parseApplication(applicationStr);\n    return new pexprs.Seq([startApp, pexprs.end]);\n  }\n}\n","import {InputStream} from './InputStream.js';\nimport {IterationNode} from './nodes.js';\nimport {MatchResult} from './MatchResult.js';\nimport * as common from './common.js';\nimport * as errors from './errors.js';\nimport * as util from './util.js';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nconst globalActionStack = [];\n\nconst hasOwnProperty = (x, prop) => Object.prototype.hasOwnProperty.call(x, prop);\n\n// ----------------- Wrappers -----------------\n\n// Wrappers decorate CST nodes with all of the functionality (i.e., operations and attributes)\n// provided by a Semantics (see below). `Wrapper` is the abstract superclass of all wrappers. A\n// `Wrapper` must have `_node` and `_semantics` instance variables, which refer to the CST node and\n// Semantics (resp.) for which it was created, and a `_childWrappers` instance variable which is\n// used to cache the wrapper instances that are created for its child nodes. Setting these instance\n// variables is the responsibility of the constructor of each Semantics-specific subclass of\n// `Wrapper`.\nclass Wrapper {\n  constructor(node, sourceInterval, baseInterval) {\n    this._node = node;\n    this.source = sourceInterval;\n\n    // The interval that the childOffsets of `node` are relative to. It should be the source\n    // of the closest Nonterminal node.\n    this._baseInterval = baseInterval;\n\n    if (node.isNonterminal()) {\n      common.assert(sourceInterval === baseInterval);\n    }\n    this._childWrappers = [];\n  }\n\n  _forgetMemoizedResultFor(attributeName) {\n    // Remove the memoized attribute from the cstNode and all its children.\n    delete this._node[this._semantics.attributeKeys[attributeName]];\n    this.children.forEach(child => {\n      child._forgetMemoizedResultFor(attributeName);\n    });\n  }\n\n  // Returns the wrapper of the specified child node. Child wrappers are created lazily and\n  // cached in the parent wrapper's `_childWrappers` instance variable.\n  child(idx) {\n    if (!(0 <= idx && idx < this._node.numChildren())) {\n      // TODO: Consider throwing an exception here.\n      return undefined;\n    }\n    let childWrapper = this._childWrappers[idx];\n    if (!childWrapper) {\n      const childNode = this._node.childAt(idx);\n      const offset = this._node.childOffsets[idx];\n\n      const source = this._baseInterval.subInterval(offset, childNode.matchLength);\n      const base = childNode.isNonterminal() ? source : this._baseInterval;\n      childWrapper = this._childWrappers[idx] = this._semantics.wrap(childNode, source, base);\n    }\n    return childWrapper;\n  }\n\n  // Returns an array containing the wrappers of all of the children of the node associated\n  // with this wrapper.\n  _children() {\n    // Force the creation of all child wrappers\n    for (let idx = 0; idx < this._node.numChildren(); idx++) {\n      this.child(idx);\n    }\n    return this._childWrappers;\n  }\n\n  // Returns `true` if the CST node associated with this wrapper corresponds to an iteration\n  // expression, i.e., a Kleene-*, Kleene-+, or an optional. Returns `false` otherwise.\n  isIteration() {\n    return this._node.isIteration();\n  }\n\n  // Returns `true` if the CST node associated with this wrapper is a terminal node, `false`\n  // otherwise.\n  isTerminal() {\n    return this._node.isTerminal();\n  }\n\n  // Returns `true` if the CST node associated with this wrapper is a nonterminal node, `false`\n  // otherwise.\n  isNonterminal() {\n    return this._node.isNonterminal();\n  }\n\n  // Returns `true` if the CST node associated with this wrapper is a nonterminal node\n  // corresponding to a syntactic rule, `false` otherwise.\n  isSyntactic() {\n    return this.isNonterminal() && this._node.isSyntactic();\n  }\n\n  // Returns `true` if the CST node associated with this wrapper is a nonterminal node\n  // corresponding to a lexical rule, `false` otherwise.\n  isLexical() {\n    return this.isNonterminal() && this._node.isLexical();\n  }\n\n  // Returns `true` if the CST node associated with this wrapper is an iterator node\n  // having either one or no child (? operator), `false` otherwise.\n  // Otherwise, throws an exception.\n  isOptional() {\n    return this._node.isOptional();\n  }\n\n  // Create a new _iter wrapper in the same semantics as this wrapper.\n  iteration(optChildWrappers) {\n    const childWrappers = optChildWrappers || [];\n\n    const childNodes = childWrappers.map(c => c._node);\n    const iter = new IterationNode(childNodes, [], -1, false);\n\n    const wrapper = this._semantics.wrap(iter, null, null);\n    wrapper._childWrappers = childWrappers;\n    return wrapper;\n  }\n\n  // Returns an array containing the children of this CST node.\n  get children() {\n    return this._children();\n  }\n\n  // Returns the name of grammar rule that created this CST node.\n  get ctorName() {\n    return this._node.ctorName;\n  }\n\n  // Returns the number of children of this CST node.\n  get numChildren() {\n    return this._node.numChildren();\n  }\n\n  // Returns the contents of the input stream consumed by this CST node.\n  get sourceString() {\n    return this.source.contents;\n  }\n}\n\n// ----------------- Semantics -----------------\n\n// A Semantics is a container for a family of Operations and Attributes for a given grammar.\n// Semantics enable modularity (different clients of a grammar can create their set of operations\n// and attributes in isolation) and extensibility even when operations and attributes are mutually-\n// recursive. This constructor should not be called directly except from\n// `Semantics.createSemantics`. The normal ways to create a Semantics, given a grammar 'g', are\n// `g.createSemantics()` and `g.extendSemantics(parentSemantics)`.\nexport class Semantics {\n  constructor(grammar, superSemantics) {\n    const self = this;\n    this.grammar = grammar;\n    this.checkedActionDicts = false;\n\n    // Constructor for wrapper instances, which are passed as the arguments to the semantic actions\n    // of an operation or attribute. Operations and attributes require double dispatch: the semantic\n    // action is chosen based on both the node's type and the semantics. Wrappers ensure that\n    // the `execute` method is called with the correct (most specific) semantics object as an\n    // argument.\n    this.Wrapper = class extends (superSemantics ? superSemantics.Wrapper : Wrapper) {\n      constructor(node, sourceInterval, baseInterval) {\n        super(node, sourceInterval, baseInterval);\n        self.checkActionDictsIfHaventAlready();\n        this._semantics = self;\n      }\n\n      toString() {\n        return '[semantics wrapper for ' + self.grammar.name + ']';\n      }\n    };\n\n    this.super = superSemantics;\n    if (superSemantics) {\n      if (!(grammar.equals(this.super.grammar) || grammar._inheritsFrom(this.super.grammar))) {\n        throw new Error(\n            \"Cannot extend a semantics for grammar '\" +\n            this.super.grammar.name +\n            \"' for use with grammar '\" +\n            grammar.name +\n            \"' (not a sub-grammar)\",\n        );\n      }\n      this.operations = Object.create(this.super.operations);\n      this.attributes = Object.create(this.super.attributes);\n      this.attributeKeys = Object.create(null);\n\n      // Assign unique symbols for each of the attributes inherited from the super-semantics so that\n      // they are memoized independently.\n      // eslint-disable-next-line guard-for-in\n      for (const attributeName in this.attributes) {\n        Object.defineProperty(this.attributeKeys, attributeName, {\n          value: util.uniqueId(attributeName),\n        });\n      }\n    } else {\n      this.operations = Object.create(null);\n      this.attributes = Object.create(null);\n      this.attributeKeys = Object.create(null);\n    }\n  }\n\n  toString() {\n    return '[semantics for ' + this.grammar.name + ']';\n  }\n\n  checkActionDictsIfHaventAlready() {\n    if (!this.checkedActionDicts) {\n      this.checkActionDicts();\n      this.checkedActionDicts = true;\n    }\n  }\n\n  // Checks that the action dictionaries for all operations and attributes in this semantics,\n  // including the ones that were inherited from the super-semantics, agree with the grammar.\n  // Throws an exception if one or more of them doesn't.\n  checkActionDicts() {\n    let name;\n    // eslint-disable-next-line guard-for-in\n    for (name in this.operations) {\n      this.operations[name].checkActionDict(this.grammar);\n    }\n    // eslint-disable-next-line guard-for-in\n    for (name in this.attributes) {\n      this.attributes[name].checkActionDict(this.grammar);\n    }\n  }\n\n  toRecipe(semanticsOnly) {\n    function hasSuperSemantics(s) {\n      return s.super !== Semantics.BuiltInSemantics._getSemantics();\n    }\n\n    let str = '(function(g) {\\n';\n    if (hasSuperSemantics(this)) {\n      str += '  var semantics = ' + this.super.toRecipe(true) + '(g';\n\n      const superSemanticsGrammar = this.super.grammar;\n      let relatedGrammar = this.grammar;\n      while (relatedGrammar !== superSemanticsGrammar) {\n        str += '.superGrammar';\n        relatedGrammar = relatedGrammar.superGrammar;\n      }\n\n      str += ');\\n';\n      str += '  return g.extendSemantics(semantics)';\n    } else {\n      str += '  return g.createSemantics()';\n    }\n    ['Operation', 'Attribute'].forEach(type => {\n      const semanticOperations = this[type.toLowerCase() + 's'];\n      Object.keys(semanticOperations).forEach(name => {\n        const {actionDict, formals, builtInDefault} = semanticOperations[name];\n\n        let signature = name;\n        if (formals.length > 0) {\n          signature += '(' + formals.join(', ') + ')';\n        }\n\n        let method;\n        if (hasSuperSemantics(this) && this.super[type.toLowerCase() + 's'][name]) {\n          method = 'extend' + type;\n        } else {\n          method = 'add' + type;\n        }\n        str += '\\n    .' + method + '(' + JSON.stringify(signature) + ', {';\n\n        const srcArray = [];\n        Object.keys(actionDict).forEach(actionName => {\n          if (actionDict[actionName] !== builtInDefault) {\n            let source = actionDict[actionName].toString().trim();\n\n            // Convert method shorthand to plain old function syntax.\n            // https://github.com/ohmjs/ohm/issues/263\n            source = source.replace(/^.*\\(/, 'function(');\n\n            srcArray.push('\\n      ' + JSON.stringify(actionName) + ': ' + source);\n          }\n        });\n        str += srcArray.join(',') + '\\n    })';\n      });\n    });\n    str += ';\\n  })';\n\n    if (!semanticsOnly) {\n      str =\n        '(function() {\\n' +\n        '  var grammar = this.fromRecipe(' +\n        this.grammar.toRecipe() +\n        ');\\n' +\n        '  var semantics = ' +\n        str +\n        '(grammar);\\n' +\n        '  return semantics;\\n' +\n        '});\\n';\n    }\n\n    return str;\n  }\n\n  addOperationOrAttribute(type, signature, actionDict) {\n    const typePlural = type + 's';\n\n    const parsedNameAndFormalArgs = parseSignature(signature, type);\n    const {name} = parsedNameAndFormalArgs;\n    const {formals} = parsedNameAndFormalArgs;\n\n    // TODO: check that there are no duplicate formal arguments\n\n    this.assertNewName(name, type);\n\n    // Create the action dictionary for this operation / attribute that contains a `_default` action\n    // which defines the default behavior of iteration, terminal, and non-terminal nodes...\n    const builtInDefault = newDefaultAction(type, name, doIt);\n    const realActionDict = {_default: builtInDefault};\n    // ... and add in the actions supplied by the programmer, which may override some or all of the\n    // default ones.\n    Object.keys(actionDict).forEach(name => {\n      realActionDict[name] = actionDict[name];\n    });\n\n    const entry =\n      type === 'operation' ?\n        new Operation(name, formals, realActionDict, builtInDefault) :\n        new Attribute(name, realActionDict, builtInDefault);\n\n    // The following check is not strictly necessary (it will happen later anyway) but it's better\n    // to catch errors early.\n    entry.checkActionDict(this.grammar);\n\n    this[typePlural][name] = entry;\n\n    function doIt(...args) {\n      // Dispatch to most specific version of this operation / attribute -- it may have been\n      // overridden by a sub-semantics.\n      const thisThing = this._semantics[typePlural][name];\n\n      // Check that the caller passed the correct number of arguments.\n      if (arguments.length !== thisThing.formals.length) {\n        throw new Error(\n            'Invalid number of arguments passed to ' +\n            name +\n            ' ' +\n            type +\n            ' (expected ' +\n            thisThing.formals.length +\n            ', got ' +\n            arguments.length +\n            ')',\n        );\n      }\n\n      // Create an \"arguments object\" from the arguments that were passed to this\n      // operation / attribute.\n      const argsObj = Object.create(null);\n      for (const [idx, val] of Object.entries(args)) {\n        const formal = thisThing.formals[idx];\n        argsObj[formal] = val;\n      }\n\n      const oldArgs = this.args;\n      this.args = argsObj;\n      const ans = thisThing.execute(this._semantics, this);\n      this.args = oldArgs;\n      return ans;\n    }\n\n    if (type === 'operation') {\n      this.Wrapper.prototype[name] = doIt;\n      this.Wrapper.prototype[name].toString = function() {\n        return '[' + name + ' operation]';\n      };\n    } else {\n      Object.defineProperty(this.Wrapper.prototype, name, {\n        get: doIt,\n        configurable: true, // So the property can be deleted.\n      });\n      Object.defineProperty(this.attributeKeys, name, {\n        value: util.uniqueId(name),\n      });\n    }\n  }\n\n  extendOperationOrAttribute(type, name, actionDict) {\n    const typePlural = type + 's';\n\n    // Make sure that `name` really is just a name, i.e., that it doesn't also contain formals.\n    parseSignature(name, 'attribute');\n\n    if (!(this.super && name in this.super[typePlural])) {\n      throw new Error(\n          'Cannot extend ' +\n          type +\n          \" '\" +\n          name +\n          \"': did not inherit an \" +\n          type +\n          ' with that name',\n      );\n    }\n    if (hasOwnProperty(this[typePlural], name)) {\n      throw new Error('Cannot extend ' + type + \" '\" + name + \"' again\");\n    }\n\n    // Create a new operation / attribute whose actionDict delegates to the super operation /\n    // attribute's actionDict, and which has all the keys from `inheritedActionDict`.\n    const inheritedFormals = this[typePlural][name].formals;\n    const inheritedActionDict = this[typePlural][name].actionDict;\n    const newActionDict = Object.create(inheritedActionDict);\n    Object.keys(actionDict).forEach(name => {\n      newActionDict[name] = actionDict[name];\n    });\n\n    this[typePlural][name] =\n      type === 'operation' ?\n        new Operation(name, inheritedFormals, newActionDict) :\n        new Attribute(name, newActionDict);\n\n    // The following check is not strictly necessary (it will happen later anyway) but it's better\n    // to catch errors early.\n    this[typePlural][name].checkActionDict(this.grammar);\n  }\n\n  assertNewName(name, type) {\n    if (hasOwnProperty(Wrapper.prototype, name)) {\n      throw new Error('Cannot add ' + type + \" '\" + name + \"': that's a reserved name\");\n    }\n    if (name in this.operations) {\n      throw new Error(\n          'Cannot add ' + type + \" '\" + name + \"': an operation with that name already exists\",\n      );\n    }\n    if (name in this.attributes) {\n      throw new Error(\n          'Cannot add ' + type + \" '\" + name + \"': an attribute with that name already exists\",\n      );\n    }\n  }\n\n  // Returns a wrapper for the given CST `node` in this semantics.\n  // If `node` is already a wrapper, returns `node` itself.  // TODO: why is this needed?\n  wrap(node, source, optBaseInterval) {\n    const baseInterval = optBaseInterval || source;\n    return node instanceof this.Wrapper ? node : new this.Wrapper(node, source, baseInterval);\n  }\n}\n\nfunction parseSignature(signature, type) {\n  if (!Semantics.prototypeGrammar) {\n    // The Operations and Attributes grammar won't be available while Ohm is loading,\n    // but we can get away the following simplification b/c none of the operations\n    // that are used while loading take arguments.\n    common.assert(signature.indexOf('(') === -1);\n    return {\n      name: signature,\n      formals: [],\n    };\n  }\n\n  const r = Semantics.prototypeGrammar.match(\n      signature,\n    type === 'operation' ? 'OperationSignature' : 'AttributeSignature',\n  );\n  if (r.failed()) {\n    throw new Error(r.message);\n  }\n\n  return Semantics.prototypeGrammarSemantics(r).parse();\n}\n\nfunction newDefaultAction(type, name, doIt) {\n  return function(...children) {\n    const thisThing = this._semantics.operations[name] || this._semantics.attributes[name];\n    const args = thisThing.formals.map(formal => this.args[formal]);\n\n    if (!this.isIteration() && children.length === 1) {\n      // This CST node corresponds to a non-terminal in the grammar (e.g., AddExpr). The fact that\n      // we got here means that this action dictionary doesn't have an action for this particular\n      // non-terminal or a generic `_nonterminal` action.\n      // As a convenience, if this node only has one child, we just return the result of applying\n      // this operation / attribute to the child node.\n      return doIt.apply(children[0], args);\n    } else {\n      // Otherwise, we throw an exception to let the programmer know that we don't know what\n      // to do with this node.\n      throw errors.missingSemanticAction(this.ctorName, name, type, globalActionStack);\n    }\n  };\n}\n\n// Creates a new Semantics instance for `grammar`, inheriting operations and attributes from\n// `optSuperSemantics`, if it is specified. Returns a function that acts as a proxy for the new\n// Semantics instance. When that function is invoked with a CST node as an argument, it returns\n// a wrapper for that node which gives access to the operations and attributes provided by this\n// semantics.\nSemantics.createSemantics = function(grammar, optSuperSemantics) {\n  const s = new Semantics(\n      grammar,\n    optSuperSemantics !== undefined ?\n      optSuperSemantics :\n      Semantics.BuiltInSemantics._getSemantics(),\n  );\n\n  // To enable clients to invoke a semantics like a function, return a function that acts as a proxy\n  // for `s`, which is the real `Semantics` instance.\n  const proxy = function ASemantics(matchResult) {\n    if (!(matchResult instanceof MatchResult)) {\n      throw new TypeError(\n          'Semantics expected a MatchResult, but got ' +\n          common.unexpectedObjToString(matchResult),\n      );\n    }\n    if (matchResult.failed()) {\n      throw new TypeError('cannot apply Semantics to ' + matchResult.toString());\n    }\n\n    const cst = matchResult._cst;\n    if (cst.grammar !== grammar) {\n      throw new Error(\n          \"Cannot use a MatchResult from grammar '\" +\n          cst.grammar.name +\n          \"' with a semantics for '\" +\n          grammar.name +\n          \"'\",\n      );\n    }\n    const inputStream = new InputStream(matchResult.input);\n    return s.wrap(cst, inputStream.interval(matchResult._cstOffset, matchResult.input.length));\n  };\n\n  // Forward public methods from the proxy to the semantics instance.\n  proxy.addOperation = function(signature, actionDict) {\n    s.addOperationOrAttribute('operation', signature, actionDict);\n    return proxy;\n  };\n  proxy.extendOperation = function(name, actionDict) {\n    s.extendOperationOrAttribute('operation', name, actionDict);\n    return proxy;\n  };\n  proxy.addAttribute = function(name, actionDict) {\n    s.addOperationOrAttribute('attribute', name, actionDict);\n    return proxy;\n  };\n  proxy.extendAttribute = function(name, actionDict) {\n    s.extendOperationOrAttribute('attribute', name, actionDict);\n    return proxy;\n  };\n  proxy._getActionDict = function(operationOrAttributeName) {\n    const action =\n      s.operations[operationOrAttributeName] || s.attributes[operationOrAttributeName];\n    if (!action) {\n      throw new Error(\n          '\"' +\n          operationOrAttributeName +\n          '\" is not a valid operation or attribute ' +\n          'name in this semantics for \"' +\n          grammar.name +\n          '\"',\n      );\n    }\n    return action.actionDict;\n  };\n  proxy._remove = function(operationOrAttributeName) {\n    let semantic;\n    if (operationOrAttributeName in s.operations) {\n      semantic = s.operations[operationOrAttributeName];\n      delete s.operations[operationOrAttributeName];\n    } else if (operationOrAttributeName in s.attributes) {\n      semantic = s.attributes[operationOrAttributeName];\n      delete s.attributes[operationOrAttributeName];\n    }\n    delete s.Wrapper.prototype[operationOrAttributeName];\n    return semantic;\n  };\n  proxy.getOperationNames = function() {\n    return Object.keys(s.operations);\n  };\n  proxy.getAttributeNames = function() {\n    return Object.keys(s.attributes);\n  };\n  proxy.getGrammar = function() {\n    return s.grammar;\n  };\n  proxy.toRecipe = function(semanticsOnly) {\n    return s.toRecipe(semanticsOnly);\n  };\n\n  // Make the proxy's toString() work.\n  proxy.toString = s.toString.bind(s);\n\n  // Returns the semantics for the proxy.\n  proxy._getSemantics = function() {\n    return s;\n  };\n\n  return proxy;\n};\n\n// ----------------- Operation -----------------\n\n// An Operation represents a function to be applied to a concrete syntax tree (CST) -- it's very\n// similar to a Visitor (http://en.wikipedia.org/wiki/Visitor_pattern). An operation is executed by\n// recursively walking the CST, and at each node, invoking the matching semantic action from\n// `actionDict`. See `Operation.prototype.execute` for details of how a CST node's matching semantic\n// action is found.\nclass Operation {\n  constructor(name, formals, actionDict, builtInDefault) {\n    this.name = name;\n    this.formals = formals;\n    this.actionDict = actionDict;\n    this.builtInDefault = builtInDefault;\n  }\n\n  checkActionDict(grammar) {\n    grammar._checkTopDownActionDict(this.typeName, this.name, this.actionDict);\n  }\n\n  // Execute this operation on the CST node associated with `nodeWrapper` in the context of the\n  // given Semantics instance.\n  execute(semantics, nodeWrapper) {\n    try {\n      // Look for a semantic action whose name matches the node's constructor name, which is either\n      // the name of a rule in the grammar, or '_terminal' (for a terminal node), or '_iter' (for an\n      // iteration node).\n      const {ctorName} = nodeWrapper._node;\n      let actionFn = this.actionDict[ctorName];\n      if (actionFn) {\n        globalActionStack.push([this, ctorName]);\n        return actionFn.apply(nodeWrapper, nodeWrapper._children());\n      }\n\n      // The action dictionary does not contain a semantic action for this specific type of node.\n      // If this is a nonterminal node and the programmer has provided a `_nonterminal` semantic\n      // action, we invoke it:\n      if (nodeWrapper.isNonterminal()) {\n        actionFn = this.actionDict._nonterminal;\n        if (actionFn) {\n          globalActionStack.push([this, '_nonterminal', ctorName]);\n          return actionFn.apply(nodeWrapper, nodeWrapper._children());\n        }\n      }\n\n      // Otherwise, we invoke the '_default' semantic action.\n      globalActionStack.push([this, 'default action', ctorName]);\n      return this.actionDict._default.apply(nodeWrapper, nodeWrapper._children());\n    } finally {\n      globalActionStack.pop();\n    }\n  }\n}\n\nOperation.prototype.typeName = 'operation';\n\n// ----------------- Attribute -----------------\n\n// Attributes are Operations whose results are memoized. This means that, for any given semantics,\n// the semantic action for a CST node will be invoked no more than once.\nclass Attribute extends Operation {\n  constructor(name, actionDict, builtInDefault) {\n    super(name, [], actionDict, builtInDefault);\n  }\n\n  execute(semantics, nodeWrapper) {\n    const node = nodeWrapper._node;\n    const key = semantics.attributeKeys[this.name];\n    if (!hasOwnProperty(node, key)) {\n      // The following is a super-send -- isn't JS beautiful? :/\n      node[key] = Operation.prototype.execute.call(this, semantics, nodeWrapper);\n    }\n    return node[key];\n  }\n}\n\nAttribute.prototype.typeName = 'attribute';\n","import {Matcher} from './Matcher.js';\nimport {Semantics} from './Semantics.js';\nimport * as common from './common.js';\nimport * as errors from './errors.js';\nimport * as pexprs from './pexprs.js';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nconst SPECIAL_ACTION_NAMES = ['_iter', '_terminal', '_nonterminal', '_default'];\n\nfunction getSortedRuleValues(grammar) {\n  return Object.keys(grammar.rules)\n      .sort()\n      .map(name => grammar.rules[name]);\n}\n\n// Until ES2019, JSON was not a valid subset of JavaScript because U+2028 (line separator)\n// and U+2029 (paragraph separator) are allowed in JSON string literals, but not in JS.\n// This function properly encodes those two characters so that the resulting string is\n// represents both valid JSON, and valid JavaScript (for ES2018 and below).\n// See https://v8.dev/features/subsume-json for more details.\nconst jsonToJS = str => str.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n\nlet ohmGrammar;\nlet buildGrammar;\n\nexport class Grammar {\n  constructor(name, superGrammar, rules, optDefaultStartRule) {\n    this.name = name;\n    this.superGrammar = superGrammar;\n    this.rules = rules;\n    if (optDefaultStartRule) {\n      if (!(optDefaultStartRule in rules)) {\n        throw new Error(\n            \"Invalid start rule: '\" +\n            optDefaultStartRule +\n            \"' is not a rule in grammar '\" +\n            name +\n            \"'\",\n        );\n      }\n      this.defaultStartRule = optDefaultStartRule;\n    }\n    this._matchStateInitializer = undefined;\n    this.supportsIncrementalParsing = true;\n  }\n\n  matcher() {\n    return new Matcher(this);\n  }\n\n  // Return true if the grammar is a built-in grammar, otherwise false.\n  // NOTE: This might give an unexpected result if called before BuiltInRules is defined!\n  isBuiltIn() {\n    return this === Grammar.ProtoBuiltInRules || this === Grammar.BuiltInRules;\n  }\n\n  equals(g) {\n    if (this === g) {\n      return true;\n    }\n    // Do the cheapest comparisons first.\n    if (\n      g == null ||\n      this.name !== g.name ||\n      this.defaultStartRule !== g.defaultStartRule ||\n      !(this.superGrammar === g.superGrammar || this.superGrammar.equals(g.superGrammar))\n    ) {\n      return false;\n    }\n    const myRules = getSortedRuleValues(this);\n    const otherRules = getSortedRuleValues(g);\n    return (\n      myRules.length === otherRules.length &&\n      myRules.every((rule, i) => {\n        return (\n          rule.description === otherRules[i].description &&\n          rule.formals.join(',') === otherRules[i].formals.join(',') &&\n          rule.body.toString() === otherRules[i].body.toString()\n        );\n      })\n    );\n  }\n\n  match(input, optStartApplication) {\n    const m = this.matcher();\n    m.replaceInputRange(0, 0, input);\n    return m.match(optStartApplication);\n  }\n\n  trace(input, optStartApplication) {\n    const m = this.matcher();\n    m.replaceInputRange(0, 0, input);\n    return m.trace(optStartApplication);\n  }\n\n  createSemantics() {\n    return Semantics.createSemantics(this);\n  }\n\n  extendSemantics(superSemantics) {\n    return Semantics.createSemantics(this, superSemantics._getSemantics());\n  }\n\n  // Check that every key in `actionDict` corresponds to a semantic action, and that it maps to\n  // a function of the correct arity. If not, throw an exception.\n  _checkTopDownActionDict(what, name, actionDict) {\n    const problems = [];\n\n    // eslint-disable-next-line guard-for-in\n    for (const k in actionDict) {\n      const v = actionDict[k];\n      const isSpecialAction = SPECIAL_ACTION_NAMES.includes(k);\n\n      if (!isSpecialAction && !(k in this.rules)) {\n        problems.push(`'${k}' is not a valid semantic action for '${this.name}'`);\n        continue;\n      }\n      if (typeof v !== 'function') {\n        problems.push(`'${k}' must be a function in an action dictionary for '${this.name}'`);\n        continue;\n      }\n      const actual = v.length;\n      const expected = this._topDownActionArity(k);\n      if (actual !== expected) {\n        let details;\n        if (k === '_iter' || k === '_nonterminal') {\n          details =\n            `it should use a rest parameter, e.g. \\`${k}(...children) {}\\`. ` +\n            'NOTE: this is new in Ohm v16 — see https://ohmjs.org/d/ati for details.';\n        } else {\n          details = `expected ${expected}, got ${actual}`;\n        }\n        problems.push(`Semantic action '${k}' has the wrong arity: ${details}`);\n      }\n    }\n    if (problems.length > 0) {\n      const prettyProblems = problems.map(problem => '- ' + problem);\n      const error = new Error(\n          [\n            `Found errors in the action dictionary of the '${name}' ${what}:`,\n            ...prettyProblems,\n          ].join('\\n'),\n      );\n      error.problems = problems;\n      throw error;\n    }\n  }\n\n  // Return the expected arity for a semantic action named `actionName`, which\n  // is either a rule name or a special action name like '_nonterminal'.\n  _topDownActionArity(actionName) {\n    // All special actions have an expected arity of 0, though all but _terminal\n    // are expected to use the rest parameter syntax (e.g. `_iter(...children)`).\n    // This is considered to have arity 0, i.e. `((...args) => {}).length` is 0.\n    return SPECIAL_ACTION_NAMES.includes(actionName) ?\n      0 :\n      this.rules[actionName].body.getArity();\n  }\n\n  _inheritsFrom(grammar) {\n    let g = this.superGrammar;\n    while (g) {\n      if (g.equals(grammar, true)) {\n        return true;\n      }\n      g = g.superGrammar;\n    }\n    return false;\n  }\n\n  toRecipe(superGrammarExpr = undefined) {\n    const metaInfo = {};\n    // Include the grammar source if it is available.\n    if (this.source) {\n      metaInfo.source = this.source.contents;\n    }\n\n    let startRule = null;\n    if (this.defaultStartRule) {\n      startRule = this.defaultStartRule;\n    }\n\n    const rules = {};\n    Object.keys(this.rules).forEach(ruleName => {\n      const ruleInfo = this.rules[ruleName];\n      const {body} = ruleInfo;\n      const isDefinition = !this.superGrammar || !this.superGrammar.rules[ruleName];\n\n      let operation;\n      if (isDefinition) {\n        operation = 'define';\n      } else {\n        operation = body instanceof pexprs.Extend ? 'extend' : 'override';\n      }\n\n      const metaInfo = {};\n      if (ruleInfo.source && this.source) {\n        const adjusted = ruleInfo.source.relativeTo(this.source);\n        metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];\n      }\n\n      const description = isDefinition ? ruleInfo.description : null;\n      const bodyRecipe = body.outputRecipe(ruleInfo.formals, this.source);\n\n      rules[ruleName] = [\n        operation, // \"define\"/\"extend\"/\"override\"\n        metaInfo,\n        description,\n        ruleInfo.formals,\n        bodyRecipe,\n      ];\n    });\n\n    // If the caller provided an expression to use for the supergrammar, use that.\n    // Otherwise, if the supergrammar is a user grammar, use its recipe inline.\n    let superGrammarOutput = 'null';\n    if (superGrammarExpr) {\n      superGrammarOutput = superGrammarExpr;\n    } else if (this.superGrammar && !this.superGrammar.isBuiltIn()) {\n      superGrammarOutput = this.superGrammar.toRecipe();\n    }\n\n    const recipeElements = [\n      ...['grammar', metaInfo, this.name].map(JSON.stringify),\n      superGrammarOutput,\n      ...[startRule, rules].map(JSON.stringify),\n    ];\n    return jsonToJS(`[${recipeElements.join(',')}]`);\n  }\n\n  // TODO: Come up with better names for these methods.\n  // TODO: Write the analog of these methods for inherited attributes.\n  toOperationActionDictionaryTemplate() {\n    return this._toOperationOrAttributeActionDictionaryTemplate();\n  }\n  toAttributeActionDictionaryTemplate() {\n    return this._toOperationOrAttributeActionDictionaryTemplate();\n  }\n\n  _toOperationOrAttributeActionDictionaryTemplate() {\n    // TODO: add the super-grammar's templates at the right place, e.g., a case for AddExpr_plus\n    // should appear next to other cases of AddExpr.\n\n    const sb = new common.StringBuffer();\n    sb.append('{');\n\n    let first = true;\n    // eslint-disable-next-line guard-for-in\n    for (const ruleName in this.rules) {\n      const {body} = this.rules[ruleName];\n      if (first) {\n        first = false;\n      } else {\n        sb.append(',');\n      }\n      sb.append('\\n');\n      sb.append('  ');\n      this.addSemanticActionTemplate(ruleName, body, sb);\n    }\n\n    sb.append('\\n}');\n    return sb.contents();\n  }\n\n  addSemanticActionTemplate(ruleName, body, sb) {\n    sb.append(ruleName);\n    sb.append(': function(');\n    const arity = this._topDownActionArity(ruleName);\n    sb.append(common.repeat('_', arity).join(', '));\n    sb.append(') {\\n');\n    sb.append('  }');\n  }\n\n  // Parse a string which expresses a rule application in this grammar, and return the\n  // resulting Apply node.\n  parseApplication(str) {\n    let app;\n    if (str.indexOf('<') === -1) {\n      // simple application\n      app = new pexprs.Apply(str);\n    } else {\n      // parameterized application\n      const cst = ohmGrammar.match(str, 'Base_application');\n      app = buildGrammar(cst, {});\n    }\n\n    // Ensure that the application is valid.\n    if (!(app.ruleName in this.rules)) {\n      throw errors.undeclaredRule(app.ruleName, this.name);\n    }\n    const {formals} = this.rules[app.ruleName];\n    if (formals.length !== app.args.length) {\n      const {source} = this.rules[app.ruleName];\n      throw errors.wrongNumberOfParameters(\n          app.ruleName,\n          formals.length,\n          app.args.length,\n          source,\n      );\n    }\n    return app;\n  }\n\n  _setUpMatchState(state) {\n    if (this._matchStateInitializer) {\n      this._matchStateInitializer(state);\n    }\n  }\n}\n\n// The following grammar contains a few rules that couldn't be written  in \"userland\".\n// At the bottom of src/main.js, we create a sub-grammar of this grammar that's called\n// `BuiltInRules`. That grammar contains several convenience rules, e.g., `letter` and\n// `digit`, and is implicitly the super-grammar of any grammar whose super-grammar\n// isn't specified.\nGrammar.ProtoBuiltInRules = new Grammar(\n    'ProtoBuiltInRules', // name\n    undefined, // supergrammar\n    {\n      any: {\n        body: pexprs.any,\n        formals: [],\n        description: 'any character',\n        primitive: true,\n      },\n      end: {\n        body: pexprs.end,\n        formals: [],\n        description: 'end of input',\n        primitive: true,\n      },\n\n      caseInsensitive: {\n        body: new pexprs.CaseInsensitiveTerminal(new pexprs.Param(0)),\n        formals: ['str'],\n        primitive: true,\n      },\n      lower: {\n        body: new pexprs.UnicodeChar('Ll'),\n        formals: [],\n        description: 'a lowercase letter',\n        primitive: true,\n      },\n      upper: {\n        body: new pexprs.UnicodeChar('Lu'),\n        formals: [],\n        description: 'an uppercase letter',\n        primitive: true,\n      },\n      // Union of Lt (titlecase), Lm (modifier), and Lo (other), i.e. any letter not in Ll or Lu.\n      unicodeLtmo: {\n        body: new pexprs.UnicodeChar('Ltmo'),\n        formals: [],\n        description: 'a Unicode character in Lt, Lm, or Lo',\n        primitive: true,\n      },\n\n      // These rules are not truly primitive (they could be written in userland) but are defined\n      // here for bootstrapping purposes.\n      spaces: {\n        body: new pexprs.Star(new pexprs.Apply('space')),\n        formals: [],\n      },\n      space: {\n        body: new pexprs.Range('\\x00', ' '),\n        formals: [],\n        description: 'a space',\n      },\n    },\n);\n\n// This method is called from main.js once Ohm has loaded.\nGrammar.initApplicationParser = function(grammar, builderFn) {\n  ohmGrammar = grammar;\n  buildGrammar = builderFn;\n};\n","import {Grammar} from './Grammar.js';\nimport {InputStream} from './InputStream.js';\nimport {getDuplicates} from './common.js';\nimport * as errors from './errors.js';\nimport * as pexprs from './pexprs.js';\n\n// --------------------------------------------------------------------\n// Private Stuff\n// --------------------------------------------------------------------\n\n// Constructors\n\nexport class GrammarDecl {\n  constructor(name) {\n    this.name = name;\n  }\n\n  // Helpers\n\n  sourceInterval(startIdx, endIdx) {\n    return this.source.subInterval(startIdx, endIdx - startIdx);\n  }\n\n  ensureSuperGrammar() {\n    if (!this.superGrammar) {\n      this.withSuperGrammar(\n        // TODO: The conditional expression below is an ugly hack. It's kind of ok because\n        // I doubt anyone will ever try to declare a grammar called `BuiltInRules`. Still,\n        // we should try to find a better way to do this.\n        this.name === 'BuiltInRules' ? Grammar.ProtoBuiltInRules : Grammar.BuiltInRules,\n      );\n    }\n    return this.superGrammar;\n  }\n\n  ensureSuperGrammarRuleForOverriding(name, source) {\n    const ruleInfo = this.ensureSuperGrammar().rules[name];\n    if (!ruleInfo) {\n      throw errors.cannotOverrideUndeclaredRule(name, this.superGrammar.name, source);\n    }\n    return ruleInfo;\n  }\n\n  installOverriddenOrExtendedRule(name, formals, body, source) {\n    const duplicateParameterNames = getDuplicates(formals);\n    if (duplicateParameterNames.length > 0) {\n      throw errors.duplicateParameterNames(name, duplicateParameterNames, source);\n    }\n    const ruleInfo = this.ensureSuperGrammar().rules[name];\n    const expectedFormals = ruleInfo.formals;\n    const expectedNumFormals = expectedFormals ? expectedFormals.length : 0;\n    if (formals.length !== expectedNumFormals) {\n      throw errors.wrongNumberOfParameters(name, expectedNumFormals, formals.length, source);\n    }\n    return this.install(name, formals, body, ruleInfo.description, source);\n  }\n\n  install(name, formals, body, description, source, primitive = false) {\n    this.rules[name] = {\n      body: body.introduceParams(formals),\n      formals,\n      description,\n      source,\n      primitive,\n    };\n    return this;\n  }\n\n  // Stuff that you should only do once\n\n  withSuperGrammar(superGrammar) {\n    if (this.superGrammar) {\n      throw new Error('the super grammar of a GrammarDecl cannot be set more than once');\n    }\n    this.superGrammar = superGrammar;\n    this.rules = Object.create(superGrammar.rules);\n\n    // Grammars with an explicit supergrammar inherit a default start rule.\n    if (!superGrammar.isBuiltIn()) {\n      this.defaultStartRule = superGrammar.defaultStartRule;\n    }\n    return this;\n  }\n\n  withDefaultStartRule(ruleName) {\n    this.defaultStartRule = ruleName;\n    return this;\n  }\n\n  withSource(source) {\n    this.source = new InputStream(source).interval(0, source.length);\n    return this;\n  }\n\n  // Creates a Grammar instance, and if it passes the sanity checks, returns it.\n  build() {\n    const grammar = new Grammar(\n        this.name,\n        this.ensureSuperGrammar(),\n        this.rules,\n        this.defaultStartRule,\n    );\n    // Initialize internal props that are inherited from the super grammar.\n    grammar._matchStateInitializer = grammar.superGrammar._matchStateInitializer;\n    grammar.supportsIncrementalParsing = grammar.superGrammar.supportsIncrementalParsing;\n\n    // TODO: change the pexpr.prototype.assert... methods to make them add\n    // exceptions to an array that's provided as an arg. Then we'll be able to\n    // show more than one error of the same type at a time.\n    // TODO: include the offending pexpr in the errors, that way we can show\n    // the part of the source that caused it.\n    const grammarErrors = [];\n    let grammarHasInvalidApplications = false;\n    Object.keys(grammar.rules).forEach(ruleName => {\n      const {body} = grammar.rules[ruleName];\n      try {\n        body.assertChoicesHaveUniformArity(ruleName);\n      } catch (e) {\n        grammarErrors.push(e);\n      }\n      try {\n        body.assertAllApplicationsAreValid(ruleName, grammar);\n      } catch (e) {\n        grammarErrors.push(e);\n        grammarHasInvalidApplications = true;\n      }\n    });\n    if (!grammarHasInvalidApplications) {\n      // The following check can only be done if the grammar has no invalid applications.\n      Object.keys(grammar.rules).forEach(ruleName => {\n        const {body} = grammar.rules[ruleName];\n        try {\n          body.assertIteratedExprsAreNotNullable(grammar, []);\n        } catch (e) {\n          grammarErrors.push(e);\n        }\n      });\n    }\n    if (grammarErrors.length > 0) {\n      errors.throwErrors(grammarErrors);\n    }\n    if (this.source) {\n      grammar.source = this.source;\n    }\n\n    return grammar;\n  }\n\n  // Rule declarations\n\n  define(name, formals, body, description, source, primitive) {\n    this.ensureSuperGrammar();\n    if (this.superGrammar.rules[name]) {\n      throw errors.duplicateRuleDeclaration(name, this.name, this.superGrammar.name, source);\n    } else if (this.rules[name]) {\n      throw errors.duplicateRuleDeclaration(name, this.name, this.name, source);\n    }\n    const duplicateParameterNames = getDuplicates(formals);\n    if (duplicateParameterNames.length > 0) {\n      throw errors.duplicateParameterNames(name, duplicateParameterNames, source);\n    }\n    return this.install(name, formals, body, description, source, primitive);\n  }\n\n  override(name, formals, body, descIgnored, source) {\n    this.ensureSuperGrammarRuleForOverriding(name, source);\n    this.installOverriddenOrExtendedRule(name, formals, body, source);\n    return this;\n  }\n\n  extend(name, formals, fragment, descIgnored, source) {\n    const ruleInfo = this.ensureSuperGrammar().rules[name];\n    if (!ruleInfo) {\n      throw errors.cannotExtendUndeclaredRule(name, this.superGrammar.name, source);\n    }\n    const body = new pexprs.Extend(this.superGrammar, name, fragment);\n    body.source = fragment.source;\n    this.installOverriddenOrExtendedRule(name, formals, body, source);\n    return this;\n  }\n}\n","import {Grammar} from './Grammar.js';\nimport {GrammarDecl} from './GrammarDecl.js';\nimport * as pexprs from './pexprs.js';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nexport class Builder {\n  constructor() {\n    this.currentDecl = null;\n    this.currentRuleName = null;\n  }\n\n  newGrammar(name) {\n    return new GrammarDecl(name);\n  }\n\n  grammar(metaInfo, name, superGrammar, defaultStartRule, rules) {\n    const gDecl = new GrammarDecl(name);\n    if (superGrammar) {\n      // `superGrammar` may be a recipe (i.e. an Array), or an actual grammar instance.\n      gDecl.withSuperGrammar(\n        superGrammar instanceof Grammar ? superGrammar : this.fromRecipe(superGrammar),\n      );\n    }\n    if (defaultStartRule) {\n      gDecl.withDefaultStartRule(defaultStartRule);\n    }\n    if (metaInfo && metaInfo.source) {\n      gDecl.withSource(metaInfo.source);\n    }\n\n    this.currentDecl = gDecl;\n    Object.keys(rules).forEach(ruleName => {\n      this.currentRuleName = ruleName;\n      const ruleRecipe = rules[ruleName];\n\n      const action = ruleRecipe[0]; // define/extend/override\n      const metaInfo = ruleRecipe[1];\n      const description = ruleRecipe[2];\n      const formals = ruleRecipe[3];\n      const body = this.fromRecipe(ruleRecipe[4]);\n\n      let source;\n      if (gDecl.source && metaInfo && metaInfo.sourceInterval) {\n        source = gDecl.source.subInterval(\n            metaInfo.sourceInterval[0],\n            metaInfo.sourceInterval[1] - metaInfo.sourceInterval[0],\n        );\n      }\n      gDecl[action](ruleName, formals, body, description, source);\n    });\n    this.currentRuleName = this.currentDecl = null;\n    return gDecl.build();\n  }\n\n  terminal(x) {\n    return new pexprs.Terminal(x);\n  }\n\n  range(from, to) {\n    return new pexprs.Range(from, to);\n  }\n\n  param(index) {\n    return new pexprs.Param(index);\n  }\n\n  alt(...termArgs) {\n    let terms = [];\n    for (let arg of termArgs) {\n      if (!(arg instanceof pexprs.PExpr)) {\n        arg = this.fromRecipe(arg);\n      }\n      if (arg instanceof pexprs.Alt) {\n        terms = terms.concat(arg.terms);\n      } else {\n        terms.push(arg);\n      }\n    }\n    return terms.length === 1 ? terms[0] : new pexprs.Alt(terms);\n  }\n\n  seq(...factorArgs) {\n    let factors = [];\n    for (let arg of factorArgs) {\n      if (!(arg instanceof pexprs.PExpr)) {\n        arg = this.fromRecipe(arg);\n      }\n      if (arg instanceof pexprs.Seq) {\n        factors = factors.concat(arg.factors);\n      } else {\n        factors.push(arg);\n      }\n    }\n    return factors.length === 1 ? factors[0] : new pexprs.Seq(factors);\n  }\n\n  star(expr) {\n    if (!(expr instanceof pexprs.PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new pexprs.Star(expr);\n  }\n\n  plus(expr) {\n    if (!(expr instanceof pexprs.PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new pexprs.Plus(expr);\n  }\n\n  opt(expr) {\n    if (!(expr instanceof pexprs.PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new pexprs.Opt(expr);\n  }\n\n  not(expr) {\n    if (!(expr instanceof pexprs.PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new pexprs.Not(expr);\n  }\n\n  lookahead(expr) {\n    if (!(expr instanceof pexprs.PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new pexprs.Lookahead(expr);\n  }\n\n  lex(expr) {\n    if (!(expr instanceof pexprs.PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new pexprs.Lex(expr);\n  }\n\n  app(ruleName, optParams) {\n    if (optParams && optParams.length > 0) {\n      optParams = optParams.map(function(param) {\n        return param instanceof pexprs.PExpr ? param : this.fromRecipe(param);\n      }, this);\n    }\n    return new pexprs.Apply(ruleName, optParams);\n  }\n\n  // Note that unlike other methods in this class, this method cannot be used as a\n  // convenience constructor. It only works with recipes, because it relies on\n  // `this.currentDecl` and `this.currentRuleName` being set.\n  splice(beforeTerms, afterTerms) {\n    return new pexprs.Splice(\n        this.currentDecl.superGrammar,\n        this.currentRuleName,\n        beforeTerms.map(term => this.fromRecipe(term)),\n        afterTerms.map(term => this.fromRecipe(term)),\n    );\n  }\n\n  fromRecipe(recipe) {\n    // the meta-info of 'grammar' is processed in Builder.grammar\n    const args = recipe[0] === 'grammar' ? recipe.slice(1) : recipe.slice(2);\n    const result = this[recipe[0]](...args);\n\n    const metaInfo = recipe[1];\n    if (metaInfo) {\n      if (metaInfo.sourceInterval && this.currentDecl) {\n        result.withSource(this.currentDecl.sourceInterval(...metaInfo.sourceInterval));\n      }\n    }\n    return result;\n  }\n}\n","import {Builder} from './Builder.js';\n\nexport function makeRecipe(recipe) {\n  if (typeof recipe === 'function') {\n    return recipe.call(new Builder());\n  } else {\n    if (typeof recipe === 'string') {\n      // stringified JSON recipe\n      recipe = JSON.parse(recipe);\n    }\n    return new Builder().fromRecipe(recipe);\n  }\n}\n","import {makeRecipe} from '../src/makeRecipe.js';\nexport default makeRecipe([\"grammar\",{\"source\":\"BuiltInRules {\\n\\n  alnum  (an alpha-numeric character)\\n    = letter\\n    | digit\\n\\n  letter  (a letter)\\n    = lower\\n    | upper\\n    | unicodeLtmo\\n\\n  digit  (a digit)\\n    = \\\"0\\\"..\\\"9\\\"\\n\\n  hexDigit  (a hexadecimal digit)\\n    = digit\\n    | \\\"a\\\"..\\\"f\\\"\\n    | \\\"A\\\"..\\\"F\\\"\\n\\n  ListOf<elem, sep>\\n    = NonemptyListOf<elem, sep>\\n    | EmptyListOf<elem, sep>\\n\\n  NonemptyListOf<elem, sep>\\n    = elem (sep elem)*\\n\\n  EmptyListOf<elem, sep>\\n    = /* nothing */\\n\\n  listOf<elem, sep>\\n    = nonemptyListOf<elem, sep>\\n    | emptyListOf<elem, sep>\\n\\n  nonemptyListOf<elem, sep>\\n    = elem (sep elem)*\\n\\n  emptyListOf<elem, sep>\\n    = /* nothing */\\n\\n  // Allows a syntactic rule application within a lexical context.\\n  applySyntactic<app> = app\\n}\"},\"BuiltInRules\",null,null,{\"alnum\":[\"define\",{\"sourceInterval\":[18,78]},\"an alpha-numeric character\",[],[\"alt\",{\"sourceInterval\":[60,78]},[\"app\",{\"sourceInterval\":[60,66]},\"letter\",[]],[\"app\",{\"sourceInterval\":[73,78]},\"digit\",[]]]],\"letter\":[\"define\",{\"sourceInterval\":[82,142]},\"a letter\",[],[\"alt\",{\"sourceInterval\":[107,142]},[\"app\",{\"sourceInterval\":[107,112]},\"lower\",[]],[\"app\",{\"sourceInterval\":[119,124]},\"upper\",[]],[\"app\",{\"sourceInterval\":[131,142]},\"unicodeLtmo\",[]]]],\"digit\":[\"define\",{\"sourceInterval\":[146,177]},\"a digit\",[],[\"range\",{\"sourceInterval\":[169,177]},\"0\",\"9\"]],\"hexDigit\":[\"define\",{\"sourceInterval\":[181,254]},\"a hexadecimal digit\",[],[\"alt\",{\"sourceInterval\":[219,254]},[\"app\",{\"sourceInterval\":[219,224]},\"digit\",[]],[\"range\",{\"sourceInterval\":[231,239]},\"a\",\"f\"],[\"range\",{\"sourceInterval\":[246,254]},\"A\",\"F\"]]],\"ListOf\":[\"define\",{\"sourceInterval\":[258,336]},null,[\"elem\",\"sep\"],[\"alt\",{\"sourceInterval\":[282,336]},[\"app\",{\"sourceInterval\":[282,307]},\"NonemptyListOf\",[[\"param\",{\"sourceInterval\":[297,301]},0],[\"param\",{\"sourceInterval\":[303,306]},1]]],[\"app\",{\"sourceInterval\":[314,336]},\"EmptyListOf\",[[\"param\",{\"sourceInterval\":[326,330]},0],[\"param\",{\"sourceInterval\":[332,335]},1]]]]],\"NonemptyListOf\":[\"define\",{\"sourceInterval\":[340,388]},null,[\"elem\",\"sep\"],[\"seq\",{\"sourceInterval\":[372,388]},[\"param\",{\"sourceInterval\":[372,376]},0],[\"star\",{\"sourceInterval\":[377,388]},[\"seq\",{\"sourceInterval\":[378,386]},[\"param\",{\"sourceInterval\":[378,381]},1],[\"param\",{\"sourceInterval\":[382,386]},0]]]]],\"EmptyListOf\":[\"define\",{\"sourceInterval\":[392,434]},null,[\"elem\",\"sep\"],[\"seq\",{\"sourceInterval\":[438,438]}]],\"listOf\":[\"define\",{\"sourceInterval\":[438,516]},null,[\"elem\",\"sep\"],[\"alt\",{\"sourceInterval\":[462,516]},[\"app\",{\"sourceInterval\":[462,487]},\"nonemptyListOf\",[[\"param\",{\"sourceInterval\":[477,481]},0],[\"param\",{\"sourceInterval\":[483,486]},1]]],[\"app\",{\"sourceInterval\":[494,516]},\"emptyListOf\",[[\"param\",{\"sourceInterval\":[506,510]},0],[\"param\",{\"sourceInterval\":[512,515]},1]]]]],\"nonemptyListOf\":[\"define\",{\"sourceInterval\":[520,568]},null,[\"elem\",\"sep\"],[\"seq\",{\"sourceInterval\":[552,568]},[\"param\",{\"sourceInterval\":[552,556]},0],[\"star\",{\"sourceInterval\":[557,568]},[\"seq\",{\"sourceInterval\":[558,566]},[\"param\",{\"sourceInterval\":[558,561]},1],[\"param\",{\"sourceInterval\":[562,566]},0]]]]],\"emptyListOf\":[\"define\",{\"sourceInterval\":[572,682]},null,[\"elem\",\"sep\"],[\"seq\",{\"sourceInterval\":[685,685]}]],\"applySyntactic\":[\"define\",{\"sourceInterval\":[685,710]},null,[\"app\"],[\"param\",{\"sourceInterval\":[707,710]},0]]}]);\n","import BuiltInRules from '../dist/built-in-rules.js';\nimport {Grammar} from './Grammar.js';\nimport {announceBuiltInRules} from './util.js';\n\nGrammar.BuiltInRules = BuiltInRules;\nannounceBuiltInRules(Grammar.BuiltInRules);\n\n// During the bootstrap process, we instantiate some grammars that require\n// the built-in rules to be loaded first (e.g., ohm-grammar.ohm). By\n// exporting `makeRecipe` here, the recipes for those grammars can encode\n// that dependency by importing it from this module.\nexport {makeRecipe} from './makeRecipe.js';\n","import {makeRecipe} from '../src/main-kernel.js';\nexport default makeRecipe([\"grammar\",{\"source\":\"Ohm {\\n\\n  Grammars\\n    = Grammar*\\n\\n  Grammar\\n    = ident SuperGrammar? \\\"{\\\" Rule* \\\"}\\\"\\n\\n  SuperGrammar\\n    = \\\"<:\\\" ident\\n\\n  Rule\\n    = ident Formals? ruleDescr? \\\"=\\\"  RuleBody  -- define\\n    | ident Formals?            \\\":=\\\" OverrideRuleBody  -- override\\n    | ident Formals?            \\\"+=\\\" RuleBody  -- extend\\n\\n  RuleBody\\n    = \\\"|\\\"? NonemptyListOf<TopLevelTerm, \\\"|\\\">\\n\\n  TopLevelTerm\\n    = Seq caseName  -- inline\\n    | Seq\\n\\n  OverrideRuleBody\\n    = \\\"|\\\"? NonemptyListOf<OverrideTopLevelTerm, \\\"|\\\">\\n\\n  OverrideTopLevelTerm\\n    = \\\"...\\\"  -- superSplice\\n    | TopLevelTerm\\n\\n  Formals\\n    = \\\"<\\\" ListOf<ident, \\\",\\\"> \\\">\\\"\\n\\n  Params\\n    = \\\"<\\\" ListOf<Seq, \\\",\\\"> \\\">\\\"\\n\\n  Alt\\n    = NonemptyListOf<Seq, \\\"|\\\">\\n\\n  Seq\\n    = Iter*\\n\\n  Iter\\n    = Pred \\\"*\\\"  -- star\\n    | Pred \\\"+\\\"  -- plus\\n    | Pred \\\"?\\\"  -- opt\\n    | Pred\\n\\n  Pred\\n    = \\\"~\\\" Lex  -- not\\n    | \\\"&\\\" Lex  -- lookahead\\n    | Lex\\n\\n  Lex\\n    = \\\"#\\\" Base  -- lex\\n    | Base\\n\\n  Base\\n    = ident Params? ~(ruleDescr? \\\"=\\\" | \\\":=\\\" | \\\"+=\\\")  -- application\\n    | oneCharTerminal \\\"..\\\" oneCharTerminal           -- range\\n    | terminal                                       -- terminal\\n    | \\\"(\\\" Alt \\\")\\\"                                    -- paren\\n\\n  ruleDescr  (a rule description)\\n    = \\\"(\\\" ruleDescrText \\\")\\\"\\n\\n  ruleDescrText\\n    = (~\\\")\\\" any)*\\n\\n  caseName\\n    = \\\"--\\\" (~\\\"\\\\n\\\" space)* name (~\\\"\\\\n\\\" space)* (\\\"\\\\n\\\" | &\\\"}\\\")\\n\\n  name  (a name)\\n    = nameFirst nameRest*\\n\\n  nameFirst\\n    = \\\"_\\\"\\n    | letter\\n\\n  nameRest\\n    = \\\"_\\\"\\n    | alnum\\n\\n  ident  (an identifier)\\n    = name\\n\\n  terminal\\n    = \\\"\\\\\\\"\\\" terminalChar* \\\"\\\\\\\"\\\"\\n\\n  oneCharTerminal\\n    = \\\"\\\\\\\"\\\" terminalChar \\\"\\\\\\\"\\\"\\n\\n  terminalChar\\n    = escapeChar\\n      | ~\\\"\\\\\\\\\\\" ~\\\"\\\\\\\"\\\" ~\\\"\\\\n\\\" \\\"\\\\u{0}\\\"..\\\"\\\\u{10FFFF}\\\"\\n\\n  escapeChar  (an escape sequence)\\n    = \\\"\\\\\\\\\\\\\\\\\\\"                                     -- backslash\\n    | \\\"\\\\\\\\\\\\\\\"\\\"                                     -- doubleQuote\\n    | \\\"\\\\\\\\\\\\'\\\"                                     -- singleQuote\\n    | \\\"\\\\\\\\b\\\"                                      -- backspace\\n    | \\\"\\\\\\\\n\\\"                                      -- lineFeed\\n    | \\\"\\\\\\\\r\\\"                                      -- carriageReturn\\n    | \\\"\\\\\\\\t\\\"                                      -- tab\\n    | \\\"\\\\\\\\u{\\\" hexDigit hexDigit? hexDigit?\\n             hexDigit? hexDigit? hexDigit? \\\"}\\\"   -- unicodeCodePoint\\n    | \\\"\\\\\\\\u\\\" hexDigit hexDigit hexDigit hexDigit  -- unicodeEscape\\n    | \\\"\\\\\\\\x\\\" hexDigit hexDigit                    -- hexEscape\\n\\n  space\\n   += comment\\n\\n  comment\\n    = \\\"//\\\" (~\\\"\\\\n\\\" any)* &(\\\"\\\\n\\\" | end)  -- singleLine\\n    | \\\"/*\\\" (~\\\"*/\\\" any)* \\\"*/\\\"  -- multiLine\\n\\n  tokens = token*\\n\\n  token = caseName | comment | ident | operator | punctuation | terminal | any\\n\\n  operator = \\\"<:\\\" | \\\"=\\\" | \\\":=\\\" | \\\"+=\\\" | \\\"*\\\" | \\\"+\\\" | \\\"?\\\" | \\\"~\\\" | \\\"&\\\"\\n\\n  punctuation = \\\"<\\\" | \\\">\\\" | \\\",\\\" | \\\"--\\\"\\n}\"},\"Ohm\",null,\"Grammars\",{\"Grammars\":[\"define\",{\"sourceInterval\":[9,32]},null,[],[\"star\",{\"sourceInterval\":[24,32]},[\"app\",{\"sourceInterval\":[24,31]},\"Grammar\",[]]]],\"Grammar\":[\"define\",{\"sourceInterval\":[36,83]},null,[],[\"seq\",{\"sourceInterval\":[50,83]},[\"app\",{\"sourceInterval\":[50,55]},\"ident\",[]],[\"opt\",{\"sourceInterval\":[56,69]},[\"app\",{\"sourceInterval\":[56,68]},\"SuperGrammar\",[]]],[\"terminal\",{\"sourceInterval\":[70,73]},\"{\"],[\"star\",{\"sourceInterval\":[74,79]},[\"app\",{\"sourceInterval\":[74,78]},\"Rule\",[]]],[\"terminal\",{\"sourceInterval\":[80,83]},\"}\"]]],\"SuperGrammar\":[\"define\",{\"sourceInterval\":[87,116]},null,[],[\"seq\",{\"sourceInterval\":[106,116]},[\"terminal\",{\"sourceInterval\":[106,110]},\"<:\"],[\"app\",{\"sourceInterval\":[111,116]},\"ident\",[]]]],\"Rule_define\":[\"define\",{\"sourceInterval\":[131,181]},null,[],[\"seq\",{\"sourceInterval\":[131,170]},[\"app\",{\"sourceInterval\":[131,136]},\"ident\",[]],[\"opt\",{\"sourceInterval\":[137,145]},[\"app\",{\"sourceInterval\":[137,144]},\"Formals\",[]]],[\"opt\",{\"sourceInterval\":[146,156]},[\"app\",{\"sourceInterval\":[146,155]},\"ruleDescr\",[]]],[\"terminal\",{\"sourceInterval\":[157,160]},\"=\"],[\"app\",{\"sourceInterval\":[162,170]},\"RuleBody\",[]]]],\"Rule_override\":[\"define\",{\"sourceInterval\":[188,248]},null,[],[\"seq\",{\"sourceInterval\":[188,235]},[\"app\",{\"sourceInterval\":[188,193]},\"ident\",[]],[\"opt\",{\"sourceInterval\":[194,202]},[\"app\",{\"sourceInterval\":[194,201]},\"Formals\",[]]],[\"terminal\",{\"sourceInterval\":[214,218]},\":=\"],[\"app\",{\"sourceInterval\":[219,235]},\"OverrideRuleBody\",[]]]],\"Rule_extend\":[\"define\",{\"sourceInterval\":[255,305]},null,[],[\"seq\",{\"sourceInterval\":[255,294]},[\"app\",{\"sourceInterval\":[255,260]},\"ident\",[]],[\"opt\",{\"sourceInterval\":[261,269]},[\"app\",{\"sourceInterval\":[261,268]},\"Formals\",[]]],[\"terminal\",{\"sourceInterval\":[281,285]},\"+=\"],[\"app\",{\"sourceInterval\":[286,294]},\"RuleBody\",[]]]],\"Rule\":[\"define\",{\"sourceInterval\":[120,305]},null,[],[\"alt\",{\"sourceInterval\":[131,305]},[\"app\",{\"sourceInterval\":[131,170]},\"Rule_define\",[]],[\"app\",{\"sourceInterval\":[188,235]},\"Rule_override\",[]],[\"app\",{\"sourceInterval\":[255,294]},\"Rule_extend\",[]]]],\"RuleBody\":[\"define\",{\"sourceInterval\":[309,362]},null,[],[\"seq\",{\"sourceInterval\":[324,362]},[\"opt\",{\"sourceInterval\":[324,328]},[\"terminal\",{\"sourceInterval\":[324,327]},\"|\"]],[\"app\",{\"sourceInterval\":[329,362]},\"NonemptyListOf\",[[\"app\",{\"sourceInterval\":[344,356]},\"TopLevelTerm\",[]],[\"terminal\",{\"sourceInterval\":[358,361]},\"|\"]]]]],\"TopLevelTerm_inline\":[\"define\",{\"sourceInterval\":[385,408]},null,[],[\"seq\",{\"sourceInterval\":[385,397]},[\"app\",{\"sourceInterval\":[385,388]},\"Seq\",[]],[\"app\",{\"sourceInterval\":[389,397]},\"caseName\",[]]]],\"TopLevelTerm\":[\"define\",{\"sourceInterval\":[366,418]},null,[],[\"alt\",{\"sourceInterval\":[385,418]},[\"app\",{\"sourceInterval\":[385,397]},\"TopLevelTerm_inline\",[]],[\"app\",{\"sourceInterval\":[415,418]},\"Seq\",[]]]],\"OverrideRuleBody\":[\"define\",{\"sourceInterval\":[422,491]},null,[],[\"seq\",{\"sourceInterval\":[445,491]},[\"opt\",{\"sourceInterval\":[445,449]},[\"terminal\",{\"sourceInterval\":[445,448]},\"|\"]],[\"app\",{\"sourceInterval\":[450,491]},\"NonemptyListOf\",[[\"app\",{\"sourceInterval\":[465,485]},\"OverrideTopLevelTerm\",[]],[\"terminal\",{\"sourceInterval\":[487,490]},\"|\"]]]]],\"OverrideTopLevelTerm_superSplice\":[\"define\",{\"sourceInterval\":[522,543]},null,[],[\"terminal\",{\"sourceInterval\":[522,527]},\"...\"]],\"OverrideTopLevelTerm\":[\"define\",{\"sourceInterval\":[495,562]},null,[],[\"alt\",{\"sourceInterval\":[522,562]},[\"app\",{\"sourceInterval\":[522,527]},\"OverrideTopLevelTerm_superSplice\",[]],[\"app\",{\"sourceInterval\":[550,562]},\"TopLevelTerm\",[]]]],\"Formals\":[\"define\",{\"sourceInterval\":[566,606]},null,[],[\"seq\",{\"sourceInterval\":[580,606]},[\"terminal\",{\"sourceInterval\":[580,583]},\"<\"],[\"app\",{\"sourceInterval\":[584,602]},\"ListOf\",[[\"app\",{\"sourceInterval\":[591,596]},\"ident\",[]],[\"terminal\",{\"sourceInterval\":[598,601]},\",\"]]],[\"terminal\",{\"sourceInterval\":[603,606]},\">\"]]],\"Params\":[\"define\",{\"sourceInterval\":[610,647]},null,[],[\"seq\",{\"sourceInterval\":[623,647]},[\"terminal\",{\"sourceInterval\":[623,626]},\"<\"],[\"app\",{\"sourceInterval\":[627,643]},\"ListOf\",[[\"app\",{\"sourceInterval\":[634,637]},\"Seq\",[]],[\"terminal\",{\"sourceInterval\":[639,642]},\",\"]]],[\"terminal\",{\"sourceInterval\":[644,647]},\">\"]]],\"Alt\":[\"define\",{\"sourceInterval\":[651,685]},null,[],[\"app\",{\"sourceInterval\":[661,685]},\"NonemptyListOf\",[[\"app\",{\"sourceInterval\":[676,679]},\"Seq\",[]],[\"terminal\",{\"sourceInterval\":[681,684]},\"|\"]]]],\"Seq\":[\"define\",{\"sourceInterval\":[689,704]},null,[],[\"star\",{\"sourceInterval\":[699,704]},[\"app\",{\"sourceInterval\":[699,703]},\"Iter\",[]]]],\"Iter_star\":[\"define\",{\"sourceInterval\":[719,736]},null,[],[\"seq\",{\"sourceInterval\":[719,727]},[\"app\",{\"sourceInterval\":[719,723]},\"Pred\",[]],[\"terminal\",{\"sourceInterval\":[724,727]},\"*\"]]],\"Iter_plus\":[\"define\",{\"sourceInterval\":[743,760]},null,[],[\"seq\",{\"sourceInterval\":[743,751]},[\"app\",{\"sourceInterval\":[743,747]},\"Pred\",[]],[\"terminal\",{\"sourceInterval\":[748,751]},\"+\"]]],\"Iter_opt\":[\"define\",{\"sourceInterval\":[767,783]},null,[],[\"seq\",{\"sourceInterval\":[767,775]},[\"app\",{\"sourceInterval\":[767,771]},\"Pred\",[]],[\"terminal\",{\"sourceInterval\":[772,775]},\"?\"]]],\"Iter\":[\"define\",{\"sourceInterval\":[708,794]},null,[],[\"alt\",{\"sourceInterval\":[719,794]},[\"app\",{\"sourceInterval\":[719,727]},\"Iter_star\",[]],[\"app\",{\"sourceInterval\":[743,751]},\"Iter_plus\",[]],[\"app\",{\"sourceInterval\":[767,775]},\"Iter_opt\",[]],[\"app\",{\"sourceInterval\":[790,794]},\"Pred\",[]]]],\"Pred_not\":[\"define\",{\"sourceInterval\":[809,824]},null,[],[\"seq\",{\"sourceInterval\":[809,816]},[\"terminal\",{\"sourceInterval\":[809,812]},\"~\"],[\"app\",{\"sourceInterval\":[813,816]},\"Lex\",[]]]],\"Pred_lookahead\":[\"define\",{\"sourceInterval\":[831,852]},null,[],[\"seq\",{\"sourceInterval\":[831,838]},[\"terminal\",{\"sourceInterval\":[831,834]},\"&\"],[\"app\",{\"sourceInterval\":[835,838]},\"Lex\",[]]]],\"Pred\":[\"define\",{\"sourceInterval\":[798,862]},null,[],[\"alt\",{\"sourceInterval\":[809,862]},[\"app\",{\"sourceInterval\":[809,816]},\"Pred_not\",[]],[\"app\",{\"sourceInterval\":[831,838]},\"Pred_lookahead\",[]],[\"app\",{\"sourceInterval\":[859,862]},\"Lex\",[]]]],\"Lex_lex\":[\"define\",{\"sourceInterval\":[876,892]},null,[],[\"seq\",{\"sourceInterval\":[876,884]},[\"terminal\",{\"sourceInterval\":[876,879]},\"#\"],[\"app\",{\"sourceInterval\":[880,884]},\"Base\",[]]]],\"Lex\":[\"define\",{\"sourceInterval\":[866,903]},null,[],[\"alt\",{\"sourceInterval\":[876,903]},[\"app\",{\"sourceInterval\":[876,884]},\"Lex_lex\",[]],[\"app\",{\"sourceInterval\":[899,903]},\"Base\",[]]]],\"Base_application\":[\"define\",{\"sourceInterval\":[918,979]},null,[],[\"seq\",{\"sourceInterval\":[918,963]},[\"app\",{\"sourceInterval\":[918,923]},\"ident\",[]],[\"opt\",{\"sourceInterval\":[924,931]},[\"app\",{\"sourceInterval\":[924,930]},\"Params\",[]]],[\"not\",{\"sourceInterval\":[932,963]},[\"alt\",{\"sourceInterval\":[934,962]},[\"seq\",{\"sourceInterval\":[934,948]},[\"opt\",{\"sourceInterval\":[934,944]},[\"app\",{\"sourceInterval\":[934,943]},\"ruleDescr\",[]]],[\"terminal\",{\"sourceInterval\":[945,948]},\"=\"]],[\"terminal\",{\"sourceInterval\":[951,955]},\":=\"],[\"terminal\",{\"sourceInterval\":[958,962]},\"+=\"]]]]],\"Base_range\":[\"define\",{\"sourceInterval\":[986,1041]},null,[],[\"seq\",{\"sourceInterval\":[986,1022]},[\"app\",{\"sourceInterval\":[986,1001]},\"oneCharTerminal\",[]],[\"terminal\",{\"sourceInterval\":[1002,1006]},\"..\"],[\"app\",{\"sourceInterval\":[1007,1022]},\"oneCharTerminal\",[]]]],\"Base_terminal\":[\"define\",{\"sourceInterval\":[1048,1106]},null,[],[\"app\",{\"sourceInterval\":[1048,1056]},\"terminal\",[]]],\"Base_paren\":[\"define\",{\"sourceInterval\":[1113,1168]},null,[],[\"seq\",{\"sourceInterval\":[1113,1124]},[\"terminal\",{\"sourceInterval\":[1113,1116]},\"(\"],[\"app\",{\"sourceInterval\":[1117,1120]},\"Alt\",[]],[\"terminal\",{\"sourceInterval\":[1121,1124]},\")\"]]],\"Base\":[\"define\",{\"sourceInterval\":[907,1168]},null,[],[\"alt\",{\"sourceInterval\":[918,1168]},[\"app\",{\"sourceInterval\":[918,963]},\"Base_application\",[]],[\"app\",{\"sourceInterval\":[986,1022]},\"Base_range\",[]],[\"app\",{\"sourceInterval\":[1048,1056]},\"Base_terminal\",[]],[\"app\",{\"sourceInterval\":[1113,1124]},\"Base_paren\",[]]]],\"ruleDescr\":[\"define\",{\"sourceInterval\":[1172,1231]},\"a rule description\",[],[\"seq\",{\"sourceInterval\":[1210,1231]},[\"terminal\",{\"sourceInterval\":[1210,1213]},\"(\"],[\"app\",{\"sourceInterval\":[1214,1227]},\"ruleDescrText\",[]],[\"terminal\",{\"sourceInterval\":[1228,1231]},\")\"]]],\"ruleDescrText\":[\"define\",{\"sourceInterval\":[1235,1266]},null,[],[\"star\",{\"sourceInterval\":[1255,1266]},[\"seq\",{\"sourceInterval\":[1256,1264]},[\"not\",{\"sourceInterval\":[1256,1260]},[\"terminal\",{\"sourceInterval\":[1257,1260]},\")\"]],[\"app\",{\"sourceInterval\":[1261,1264]},\"any\",[]]]]],\"caseName\":[\"define\",{\"sourceInterval\":[1270,1338]},null,[],[\"seq\",{\"sourceInterval\":[1285,1338]},[\"terminal\",{\"sourceInterval\":[1285,1289]},\"--\"],[\"star\",{\"sourceInterval\":[1290,1304]},[\"seq\",{\"sourceInterval\":[1291,1302]},[\"not\",{\"sourceInterval\":[1291,1296]},[\"terminal\",{\"sourceInterval\":[1292,1296]},\"\\n\"]],[\"app\",{\"sourceInterval\":[1297,1302]},\"space\",[]]]],[\"app\",{\"sourceInterval\":[1305,1309]},\"name\",[]],[\"star\",{\"sourceInterval\":[1310,1324]},[\"seq\",{\"sourceInterval\":[1311,1322]},[\"not\",{\"sourceInterval\":[1311,1316]},[\"terminal\",{\"sourceInterval\":[1312,1316]},\"\\n\"]],[\"app\",{\"sourceInterval\":[1317,1322]},\"space\",[]]]],[\"alt\",{\"sourceInterval\":[1326,1337]},[\"terminal\",{\"sourceInterval\":[1326,1330]},\"\\n\"],[\"lookahead\",{\"sourceInterval\":[1333,1337]},[\"terminal\",{\"sourceInterval\":[1334,1337]},\"}\"]]]]],\"name\":[\"define\",{\"sourceInterval\":[1342,1382]},\"a name\",[],[\"seq\",{\"sourceInterval\":[1363,1382]},[\"app\",{\"sourceInterval\":[1363,1372]},\"nameFirst\",[]],[\"star\",{\"sourceInterval\":[1373,1382]},[\"app\",{\"sourceInterval\":[1373,1381]},\"nameRest\",[]]]]],\"nameFirst\":[\"define\",{\"sourceInterval\":[1386,1418]},null,[],[\"alt\",{\"sourceInterval\":[1402,1418]},[\"terminal\",{\"sourceInterval\":[1402,1405]},\"_\"],[\"app\",{\"sourceInterval\":[1412,1418]},\"letter\",[]]]],\"nameRest\":[\"define\",{\"sourceInterval\":[1422,1452]},null,[],[\"alt\",{\"sourceInterval\":[1437,1452]},[\"terminal\",{\"sourceInterval\":[1437,1440]},\"_\"],[\"app\",{\"sourceInterval\":[1447,1452]},\"alnum\",[]]]],\"ident\":[\"define\",{\"sourceInterval\":[1456,1489]},\"an identifier\",[],[\"app\",{\"sourceInterval\":[1485,1489]},\"name\",[]]],\"terminal\":[\"define\",{\"sourceInterval\":[1493,1531]},null,[],[\"seq\",{\"sourceInterval\":[1508,1531]},[\"terminal\",{\"sourceInterval\":[1508,1512]},\"\\\"\"],[\"star\",{\"sourceInterval\":[1513,1526]},[\"app\",{\"sourceInterval\":[1513,1525]},\"terminalChar\",[]]],[\"terminal\",{\"sourceInterval\":[1527,1531]},\"\\\"\"]]],\"oneCharTerminal\":[\"define\",{\"sourceInterval\":[1535,1579]},null,[],[\"seq\",{\"sourceInterval\":[1557,1579]},[\"terminal\",{\"sourceInterval\":[1557,1561]},\"\\\"\"],[\"app\",{\"sourceInterval\":[1562,1574]},\"terminalChar\",[]],[\"terminal\",{\"sourceInterval\":[1575,1579]},\"\\\"\"]]],\"terminalChar\":[\"define\",{\"sourceInterval\":[1583,1660]},null,[],[\"alt\",{\"sourceInterval\":[1602,1660]},[\"app\",{\"sourceInterval\":[1602,1612]},\"escapeChar\",[]],[\"seq\",{\"sourceInterval\":[1621,1660]},[\"not\",{\"sourceInterval\":[1621,1626]},[\"terminal\",{\"sourceInterval\":[1622,1626]},\"\\\\\"]],[\"not\",{\"sourceInterval\":[1627,1632]},[\"terminal\",{\"sourceInterval\":[1628,1632]},\"\\\"\"]],[\"not\",{\"sourceInterval\":[1633,1638]},[\"terminal\",{\"sourceInterval\":[1634,1638]},\"\\n\"]],[\"range\",{\"sourceInterval\":[1639,1660]},\"\\u0000\",\"􏿿\"]]]],\"escapeChar_backslash\":[\"define\",{\"sourceInterval\":[1703,1758]},null,[],[\"terminal\",{\"sourceInterval\":[1703,1709]},\"\\\\\\\\\"]],\"escapeChar_doubleQuote\":[\"define\",{\"sourceInterval\":[1765,1822]},null,[],[\"terminal\",{\"sourceInterval\":[1765,1771]},\"\\\\\\\"\"]],\"escapeChar_singleQuote\":[\"define\",{\"sourceInterval\":[1829,1886]},null,[],[\"terminal\",{\"sourceInterval\":[1829,1835]},\"\\\\'\"]],\"escapeChar_backspace\":[\"define\",{\"sourceInterval\":[1893,1948]},null,[],[\"terminal\",{\"sourceInterval\":[1893,1898]},\"\\\\b\"]],\"escapeChar_lineFeed\":[\"define\",{\"sourceInterval\":[1955,2009]},null,[],[\"terminal\",{\"sourceInterval\":[1955,1960]},\"\\\\n\"]],\"escapeChar_carriageReturn\":[\"define\",{\"sourceInterval\":[2016,2076]},null,[],[\"terminal\",{\"sourceInterval\":[2016,2021]},\"\\\\r\"]],\"escapeChar_tab\":[\"define\",{\"sourceInterval\":[2083,2132]},null,[],[\"terminal\",{\"sourceInterval\":[2083,2088]},\"\\\\t\"]],\"escapeChar_unicodeCodePoint\":[\"define\",{\"sourceInterval\":[2139,2243]},null,[],[\"seq\",{\"sourceInterval\":[2139,2221]},[\"terminal\",{\"sourceInterval\":[2139,2145]},\"\\\\u{\"],[\"app\",{\"sourceInterval\":[2146,2154]},\"hexDigit\",[]],[\"opt\",{\"sourceInterval\":[2155,2164]},[\"app\",{\"sourceInterval\":[2155,2163]},\"hexDigit\",[]]],[\"opt\",{\"sourceInterval\":[2165,2174]},[\"app\",{\"sourceInterval\":[2165,2173]},\"hexDigit\",[]]],[\"opt\",{\"sourceInterval\":[2188,2197]},[\"app\",{\"sourceInterval\":[2188,2196]},\"hexDigit\",[]]],[\"opt\",{\"sourceInterval\":[2198,2207]},[\"app\",{\"sourceInterval\":[2198,2206]},\"hexDigit\",[]]],[\"opt\",{\"sourceInterval\":[2208,2217]},[\"app\",{\"sourceInterval\":[2208,2216]},\"hexDigit\",[]]],[\"terminal\",{\"sourceInterval\":[2218,2221]},\"}\"]]],\"escapeChar_unicodeEscape\":[\"define\",{\"sourceInterval\":[2250,2309]},null,[],[\"seq\",{\"sourceInterval\":[2250,2291]},[\"terminal\",{\"sourceInterval\":[2250,2255]},\"\\\\u\"],[\"app\",{\"sourceInterval\":[2256,2264]},\"hexDigit\",[]],[\"app\",{\"sourceInterval\":[2265,2273]},\"hexDigit\",[]],[\"app\",{\"sourceInterval\":[2274,2282]},\"hexDigit\",[]],[\"app\",{\"sourceInterval\":[2283,2291]},\"hexDigit\",[]]]],\"escapeChar_hexEscape\":[\"define\",{\"sourceInterval\":[2316,2371]},null,[],[\"seq\",{\"sourceInterval\":[2316,2339]},[\"terminal\",{\"sourceInterval\":[2316,2321]},\"\\\\x\"],[\"app\",{\"sourceInterval\":[2322,2330]},\"hexDigit\",[]],[\"app\",{\"sourceInterval\":[2331,2339]},\"hexDigit\",[]]]],\"escapeChar\":[\"define\",{\"sourceInterval\":[1664,2371]},\"an escape sequence\",[],[\"alt\",{\"sourceInterval\":[1703,2371]},[\"app\",{\"sourceInterval\":[1703,1709]},\"escapeChar_backslash\",[]],[\"app\",{\"sourceInterval\":[1765,1771]},\"escapeChar_doubleQuote\",[]],[\"app\",{\"sourceInterval\":[1829,1835]},\"escapeChar_singleQuote\",[]],[\"app\",{\"sourceInterval\":[1893,1898]},\"escapeChar_backspace\",[]],[\"app\",{\"sourceInterval\":[1955,1960]},\"escapeChar_lineFeed\",[]],[\"app\",{\"sourceInterval\":[2016,2021]},\"escapeChar_carriageReturn\",[]],[\"app\",{\"sourceInterval\":[2083,2088]},\"escapeChar_tab\",[]],[\"app\",{\"sourceInterval\":[2139,2221]},\"escapeChar_unicodeCodePoint\",[]],[\"app\",{\"sourceInterval\":[2250,2291]},\"escapeChar_unicodeEscape\",[]],[\"app\",{\"sourceInterval\":[2316,2339]},\"escapeChar_hexEscape\",[]]]],\"space\":[\"extend\",{\"sourceInterval\":[2375,2394]},null,[],[\"app\",{\"sourceInterval\":[2387,2394]},\"comment\",[]]],\"comment_singleLine\":[\"define\",{\"sourceInterval\":[2412,2458]},null,[],[\"seq\",{\"sourceInterval\":[2412,2443]},[\"terminal\",{\"sourceInterval\":[2412,2416]},\"//\"],[\"star\",{\"sourceInterval\":[2417,2429]},[\"seq\",{\"sourceInterval\":[2418,2427]},[\"not\",{\"sourceInterval\":[2418,2423]},[\"terminal\",{\"sourceInterval\":[2419,2423]},\"\\n\"]],[\"app\",{\"sourceInterval\":[2424,2427]},\"any\",[]]]],[\"lookahead\",{\"sourceInterval\":[2430,2443]},[\"alt\",{\"sourceInterval\":[2432,2442]},[\"terminal\",{\"sourceInterval\":[2432,2436]},\"\\n\"],[\"app\",{\"sourceInterval\":[2439,2442]},\"end\",[]]]]]],\"comment_multiLine\":[\"define\",{\"sourceInterval\":[2465,2501]},null,[],[\"seq\",{\"sourceInterval\":[2465,2487]},[\"terminal\",{\"sourceInterval\":[2465,2469]},\"/*\"],[\"star\",{\"sourceInterval\":[2470,2482]},[\"seq\",{\"sourceInterval\":[2471,2480]},[\"not\",{\"sourceInterval\":[2471,2476]},[\"terminal\",{\"sourceInterval\":[2472,2476]},\"*/\"]],[\"app\",{\"sourceInterval\":[2477,2480]},\"any\",[]]]],[\"terminal\",{\"sourceInterval\":[2483,2487]},\"*/\"]]],\"comment\":[\"define\",{\"sourceInterval\":[2398,2501]},null,[],[\"alt\",{\"sourceInterval\":[2412,2501]},[\"app\",{\"sourceInterval\":[2412,2443]},\"comment_singleLine\",[]],[\"app\",{\"sourceInterval\":[2465,2487]},\"comment_multiLine\",[]]]],\"tokens\":[\"define\",{\"sourceInterval\":[2505,2520]},null,[],[\"star\",{\"sourceInterval\":[2514,2520]},[\"app\",{\"sourceInterval\":[2514,2519]},\"token\",[]]]],\"token\":[\"define\",{\"sourceInterval\":[2524,2600]},null,[],[\"alt\",{\"sourceInterval\":[2532,2600]},[\"app\",{\"sourceInterval\":[2532,2540]},\"caseName\",[]],[\"app\",{\"sourceInterval\":[2543,2550]},\"comment\",[]],[\"app\",{\"sourceInterval\":[2553,2558]},\"ident\",[]],[\"app\",{\"sourceInterval\":[2561,2569]},\"operator\",[]],[\"app\",{\"sourceInterval\":[2572,2583]},\"punctuation\",[]],[\"app\",{\"sourceInterval\":[2586,2594]},\"terminal\",[]],[\"app\",{\"sourceInterval\":[2597,2600]},\"any\",[]]]],\"operator\":[\"define\",{\"sourceInterval\":[2604,2669]},null,[],[\"alt\",{\"sourceInterval\":[2615,2669]},[\"terminal\",{\"sourceInterval\":[2615,2619]},\"<:\"],[\"terminal\",{\"sourceInterval\":[2622,2625]},\"=\"],[\"terminal\",{\"sourceInterval\":[2628,2632]},\":=\"],[\"terminal\",{\"sourceInterval\":[2635,2639]},\"+=\"],[\"terminal\",{\"sourceInterval\":[2642,2645]},\"*\"],[\"terminal\",{\"sourceInterval\":[2648,2651]},\"+\"],[\"terminal\",{\"sourceInterval\":[2654,2657]},\"?\"],[\"terminal\",{\"sourceInterval\":[2660,2663]},\"~\"],[\"terminal\",{\"sourceInterval\":[2666,2669]},\"&\"]]],\"punctuation\":[\"define\",{\"sourceInterval\":[2673,2709]},null,[],[\"alt\",{\"sourceInterval\":[2687,2709]},[\"terminal\",{\"sourceInterval\":[2687,2690]},\"<\"],[\"terminal\",{\"sourceInterval\":[2693,2696]},\">\"],[\"terminal\",{\"sourceInterval\":[2699,2702]},\",\"],[\"terminal\",{\"sourceInterval\":[2705,2709]},\"--\"]]]}]);\n","import ohmGrammar from '../dist/ohm-grammar.js';\nimport {Builder} from './Builder.js';\nimport * as common from './common.js';\nimport * as errors from './errors.js';\nimport {Grammar} from './Grammar.js';\nimport * as pexprs from './pexprs.js';\n\nconst superSplicePlaceholder = Object.create(pexprs.PExpr.prototype);\n\nfunction namespaceHas(ns, name) {\n  // Look for an enumerable property, anywhere in the prototype chain.\n  for (const prop in ns) {\n    if (prop === name) return true;\n  }\n  return false;\n}\n\n// Returns a Grammar instance (i.e., an object with a `match` method) for\n// `tree`, which is the concrete syntax tree of a user-written grammar.\n// The grammar will be assigned into `namespace` under the name of the grammar\n// as specified in the source.\nexport function buildGrammar(match, namespace, optOhmGrammarForTesting) {\n  const builder = new Builder();\n  let decl;\n  let currentRuleName;\n  let currentRuleFormals;\n  let overriding = false;\n  const metaGrammar = optOhmGrammarForTesting || ohmGrammar;\n\n  // A visitor that produces a Grammar instance from the CST.\n  const helpers = metaGrammar.createSemantics().addOperation('visit', {\n    Grammars(grammarIter) {\n      return grammarIter.children.map(c => c.visit());\n    },\n    Grammar(id, s, _open, rules, _close) {\n      const grammarName = id.visit();\n      decl = builder.newGrammar(grammarName);\n      s.child(0) && s.child(0).visit();\n      rules.children.map(c => c.visit());\n      const g = decl.build();\n      g.source = this.source.trimmed();\n      if (namespaceHas(namespace, grammarName)) {\n        throw errors.duplicateGrammarDeclaration(g, namespace);\n      }\n      namespace[grammarName] = g;\n      return g;\n    },\n\n    SuperGrammar(_, n) {\n      const superGrammarName = n.visit();\n      if (superGrammarName === 'null') {\n        decl.withSuperGrammar(null);\n      } else {\n        if (!namespace || !namespaceHas(namespace, superGrammarName)) {\n          throw errors.undeclaredGrammar(superGrammarName, namespace, n.source);\n        }\n        decl.withSuperGrammar(namespace[superGrammarName]);\n      }\n    },\n\n    Rule_define(n, fs, d, _, b) {\n      currentRuleName = n.visit();\n      currentRuleFormals = fs.children.map(c => c.visit())[0] || [];\n      // If there is no default start rule yet, set it now. This must be done before visiting\n      // the body, because it might contain an inline rule definition.\n      if (!decl.defaultStartRule && decl.ensureSuperGrammar() !== Grammar.ProtoBuiltInRules) {\n        decl.withDefaultStartRule(currentRuleName);\n      }\n      const body = b.visit();\n      const description = d.children.map(c => c.visit())[0];\n      const source = this.source.trimmed();\n      return decl.define(currentRuleName, currentRuleFormals, body, description, source);\n    },\n    Rule_override(n, fs, _, b) {\n      currentRuleName = n.visit();\n      currentRuleFormals = fs.children.map(c => c.visit())[0] || [];\n\n      const source = this.source.trimmed();\n      decl.ensureSuperGrammarRuleForOverriding(currentRuleName, source);\n\n      overriding = true;\n      const body = b.visit();\n      overriding = false;\n      return decl.override(currentRuleName, currentRuleFormals, body, null, source);\n    },\n    Rule_extend(n, fs, _, b) {\n      currentRuleName = n.visit();\n      currentRuleFormals = fs.children.map(c => c.visit())[0] || [];\n      const body = b.visit();\n      const source = this.source.trimmed();\n      return decl.extend(currentRuleName, currentRuleFormals, body, null, source);\n    },\n    RuleBody(_, terms) {\n      return builder.alt(...terms.visit()).withSource(this.source);\n    },\n    OverrideRuleBody(_, terms) {\n      const args = terms.visit();\n\n      // Check if the super-splice operator (`...`) appears in the terms.\n      const expansionPos = args.indexOf(superSplicePlaceholder);\n      if (expansionPos >= 0) {\n        const beforeTerms = args.slice(0, expansionPos);\n        const afterTerms = args.slice(expansionPos + 1);\n\n        // Ensure it appears no more than once.\n        afterTerms.forEach(t => {\n          if (t === superSplicePlaceholder) throw errors.multipleSuperSplices(t);\n        });\n\n        return new pexprs.Splice(\n            decl.superGrammar,\n            currentRuleName,\n            beforeTerms,\n            afterTerms,\n        ).withSource(this.source);\n      } else {\n        return builder.alt(...args).withSource(this.source);\n      }\n    },\n    Formals(opointy, fs, cpointy) {\n      return fs.visit();\n    },\n\n    Params(opointy, ps, cpointy) {\n      return ps.visit();\n    },\n\n    Alt(seqs) {\n      return builder.alt(...seqs.visit()).withSource(this.source);\n    },\n\n    TopLevelTerm_inline(b, n) {\n      const inlineRuleName = currentRuleName + '_' + n.visit();\n      const body = b.visit();\n      const source = this.source.trimmed();\n      const isNewRuleDeclaration = !(\n        decl.superGrammar && decl.superGrammar.rules[inlineRuleName]\n      );\n      if (overriding && !isNewRuleDeclaration) {\n        decl.override(inlineRuleName, currentRuleFormals, body, null, source);\n      } else {\n        decl.define(inlineRuleName, currentRuleFormals, body, null, source);\n      }\n      const params = currentRuleFormals.map(formal => builder.app(formal));\n      return builder.app(inlineRuleName, params).withSource(body.source);\n    },\n    OverrideTopLevelTerm_superSplice(_) {\n      return superSplicePlaceholder;\n    },\n\n    Seq(expr) {\n      return builder.seq(...expr.children.map(c => c.visit())).withSource(this.source);\n    },\n\n    Iter_star(x, _) {\n      return builder.star(x.visit()).withSource(this.source);\n    },\n    Iter_plus(x, _) {\n      return builder.plus(x.visit()).withSource(this.source);\n    },\n    Iter_opt(x, _) {\n      return builder.opt(x.visit()).withSource(this.source);\n    },\n\n    Pred_not(_, x) {\n      return builder.not(x.visit()).withSource(this.source);\n    },\n    Pred_lookahead(_, x) {\n      return builder.lookahead(x.visit()).withSource(this.source);\n    },\n\n    Lex_lex(_, x) {\n      return builder.lex(x.visit()).withSource(this.source);\n    },\n\n    Base_application(rule, ps) {\n      const params = ps.children.map(c => c.visit())[0] || [];\n      return builder.app(rule.visit(), params).withSource(this.source);\n    },\n    Base_range(from, _, to) {\n      return builder.range(from.visit(), to.visit()).withSource(this.source);\n    },\n    Base_terminal(expr) {\n      return builder.terminal(expr.visit()).withSource(this.source);\n    },\n    Base_paren(open, x, close) {\n      return x.visit();\n    },\n\n    ruleDescr(open, t, close) {\n      return t.visit();\n    },\n    ruleDescrText(_) {\n      return this.sourceString.trim();\n    },\n\n    caseName(_, space1, n, space2, end) {\n      return n.visit();\n    },\n\n    name(first, rest) {\n      return this.sourceString;\n    },\n    nameFirst(expr) {},\n    nameRest(expr) {},\n\n    terminal(open, cs, close) {\n      return cs.children.map(c => c.visit()).join('');\n    },\n\n    oneCharTerminal(open, c, close) {\n      return c.visit();\n    },\n\n    escapeChar(c) {\n      try {\n        return common.unescapeCodePoint(this.sourceString);\n      } catch (err) {\n        if (err instanceof RangeError && err.message.startsWith('Invalid code point ')) {\n          throw errors.invalidCodePoint(c);\n        }\n        throw err; // Rethrow\n      }\n    },\n\n    NonemptyListOf(x, _, xs) {\n      return [x.visit()].concat(xs.children.map(c => c.visit()));\n    },\n    EmptyListOf() {\n      return [];\n    },\n\n    _terminal() {\n      return this.sourceString;\n    },\n  });\n  return helpers(match).visit();\n}\n","import {makeRecipe} from '../src/main-kernel.js';\nexport default makeRecipe([\"grammar\",{\"source\":\"OperationsAndAttributes {\\n\\n  AttributeSignature =\\n    name\\n\\n  OperationSignature =\\n    name Formals?\\n\\n  Formals\\n    = \\\"(\\\" ListOf<name, \\\",\\\"> \\\")\\\"\\n\\n  name  (a name)\\n    = nameFirst nameRest*\\n\\n  nameFirst\\n    = \\\"_\\\"\\n    | letter\\n\\n  nameRest\\n    = \\\"_\\\"\\n    | alnum\\n\\n}\"},\"OperationsAndAttributes\",null,\"AttributeSignature\",{\"AttributeSignature\":[\"define\",{\"sourceInterval\":[29,58]},null,[],[\"app\",{\"sourceInterval\":[54,58]},\"name\",[]]],\"OperationSignature\":[\"define\",{\"sourceInterval\":[62,100]},null,[],[\"seq\",{\"sourceInterval\":[87,100]},[\"app\",{\"sourceInterval\":[87,91]},\"name\",[]],[\"opt\",{\"sourceInterval\":[92,100]},[\"app\",{\"sourceInterval\":[92,99]},\"Formals\",[]]]]],\"Formals\":[\"define\",{\"sourceInterval\":[104,143]},null,[],[\"seq\",{\"sourceInterval\":[118,143]},[\"terminal\",{\"sourceInterval\":[118,121]},\"(\"],[\"app\",{\"sourceInterval\":[122,139]},\"ListOf\",[[\"app\",{\"sourceInterval\":[129,133]},\"name\",[]],[\"terminal\",{\"sourceInterval\":[135,138]},\",\"]]],[\"terminal\",{\"sourceInterval\":[140,143]},\")\"]]],\"name\":[\"define\",{\"sourceInterval\":[147,187]},\"a name\",[],[\"seq\",{\"sourceInterval\":[168,187]},[\"app\",{\"sourceInterval\":[168,177]},\"nameFirst\",[]],[\"star\",{\"sourceInterval\":[178,187]},[\"app\",{\"sourceInterval\":[178,186]},\"nameRest\",[]]]]],\"nameFirst\":[\"define\",{\"sourceInterval\":[191,223]},null,[],[\"alt\",{\"sourceInterval\":[207,223]},[\"terminal\",{\"sourceInterval\":[207,210]},\"_\"],[\"app\",{\"sourceInterval\":[217,223]},\"letter\",[]]]],\"nameRest\":[\"define\",{\"sourceInterval\":[227,257]},null,[],[\"alt\",{\"sourceInterval\":[242,257]},[\"terminal\",{\"sourceInterval\":[242,245]},\"_\"],[\"app\",{\"sourceInterval\":[252,257]},\"alnum\",[]]]]}]);\n","import operationsAndAttributesGrammar from '../dist/operations-and-attributes.js';\nimport {Grammar} from './Grammar.js';\nimport {Semantics} from './Semantics.js';\n\ninitBuiltInSemantics(Grammar.BuiltInRules);\ninitPrototypeParser(operationsAndAttributesGrammar); // requires BuiltInSemantics\n\nfunction initBuiltInSemantics(builtInRules) {\n  const actions = {\n    empty() {\n      return this.iteration();\n    },\n    nonEmpty(first, _, rest) {\n      return this.iteration([first].concat(rest.children));\n    },\n    self(..._children) {\n      return this;\n    },\n  };\n\n  Semantics.BuiltInSemantics = Semantics.createSemantics(builtInRules, null).addOperation(\n      'asIteration',\n      {\n        emptyListOf: actions.empty,\n        nonemptyListOf: actions.nonEmpty,\n        EmptyListOf: actions.empty,\n        NonemptyListOf: actions.nonEmpty,\n        _iter: actions.self,\n      },\n  );\n}\n\nfunction initPrototypeParser(grammar) {\n  Semantics.prototypeGrammarSemantics = grammar.createSemantics().addOperation('parse', {\n    AttributeSignature(name) {\n      return {\n        name: name.parse(),\n        formals: [],\n      };\n    },\n    OperationSignature(name, optFormals) {\n      return {\n        name: name.parse(),\n        formals: optFormals.children.map(c => c.parse())[0] || [],\n      };\n    },\n    Formals(oparen, fs, cparen) {\n      return fs.asIteration().children.map(c => c.parse());\n    },\n    name(first, rest) {\n      return this.sourceString;\n    },\n  });\n  Semantics.prototypeGrammar = grammar;\n}\n","export function findIndentation(input) {\n  let pos = 0;\n  const stack = [0];\n  const topOfStack = () => stack[stack.length - 1];\n\n  const result = {};\n\n  const regex = /( *).*(?:$|\\r?\\n|\\r)/g;\n  let match;\n  while ((match = regex.exec(input)) != null) {\n    const [line, indent] = match;\n\n    // The last match will always have length 0. In every other case, some\n    // characters will be matched (possibly only the end of line chars).\n    if (line.length === 0) break;\n\n    const indentSize = indent.length;\n    const prevSize = topOfStack();\n\n    const indentPos = pos + indentSize;\n\n    if (indentSize > prevSize) {\n      // Indent -- always only 1.\n      stack.push(indentSize);\n      result[indentPos] = 1;\n    } else if (indentSize < prevSize) {\n      // Dedent -- can be multiple levels.\n      const prevLength = stack.length;\n      while (topOfStack() !== indentSize) {\n        stack.pop();\n      }\n      result[indentPos] = -1 * (prevLength - stack.length);\n    }\n    pos += line.length;\n  }\n  // Ensure that there is a matching DEDENT for every remaining INDENT.\n  if (stack.length > 1) {\n    result[pos] = 1 - stack.length;\n  }\n  return result;\n}\n","import BuiltInRules from '../dist/built-in-rules.js';\nimport {Builder} from '../src/Builder.js';\nimport {Failure} from '../src/Failure.js';\nimport {TerminalNode} from '../src/nodes.js';\nimport * as pexprs from '../src/pexprs.js';\nimport {findIndentation} from './findIndentation.js';\nimport {InputStream} from './InputStream.js';\n\nconst INDENT_DESCRIPTION = 'an indented block';\nconst DEDENT_DESCRIPTION = 'a dedent';\n\n// A sentinel value that is out of range for both charCodeAt() and codePointAt().\nconst INVALID_CODE_POINT = 0x10ffff + 1;\n\nclass InputStreamWithIndentation extends InputStream {\n  constructor(state) {\n    super(state.input);\n    this.state = state;\n  }\n\n  _indentationAt(pos) {\n    return this.state.userData[pos] || 0;\n  }\n\n  atEnd() {\n    return super.atEnd() && this._indentationAt(this.pos) === 0;\n  }\n\n  next() {\n    if (this._indentationAt(this.pos) !== 0) {\n      this.examinedLength = Math.max(this.examinedLength, this.pos);\n      return undefined;\n    }\n    return super.next();\n  }\n\n  nextCharCode() {\n    if (this._indentationAt(this.pos) !== 0) {\n      this.examinedLength = Math.max(this.examinedLength, this.pos);\n      return INVALID_CODE_POINT;\n    }\n    return super.nextCharCode();\n  }\n\n  nextCodePoint() {\n    if (this._indentationAt(this.pos) !== 0) {\n      this.examinedLength = Math.max(this.examinedLength, this.pos);\n      return INVALID_CODE_POINT;\n    }\n    return super.nextCodePoint();\n  }\n}\n\nclass Indentation extends pexprs.PExpr {\n  constructor(isIndent = true) {\n    super();\n    this.isIndent = isIndent;\n  }\n\n  allowsSkippingPrecedingSpace() {\n    return true;\n  }\n\n  eval(state) {\n    const {inputStream} = state;\n    const pseudoTokens = state.userData;\n    state.doNotMemoize = true;\n\n    const origPos = inputStream.pos;\n\n    const sign = this.isIndent ? 1 : -1;\n    const count = (pseudoTokens[origPos] || 0) * sign;\n    if (count > 0) {\n      // Update the count to consume the pseudotoken.\n      state.userData = Object.create(pseudoTokens);\n      state.userData[origPos] -= sign;\n\n      state.pushBinding(new TerminalNode(0), origPos);\n      return true;\n    } else {\n      state.processFailure(origPos, this);\n      return false;\n    }\n  }\n\n  getArity() {\n    return 1;\n  }\n\n  _assertAllApplicationsAreValid(ruleName, grammar) {}\n\n  _isNullable(grammar, memo) {\n    return false;\n  }\n\n  assertChoicesHaveUniformArity(ruleName) {}\n\n  assertIteratedExprsAreNotNullable(grammar) {}\n\n  introduceParams(formals) {\n    return this;\n  }\n\n  substituteParams(actuals) {\n    return this;\n  }\n\n  toString() {\n    return this.isIndent ? 'indent' : 'dedent';\n  }\n\n  toDisplayString() {\n    return this.toString();\n  }\n\n  toFailure(grammar) {\n    const description = this.isIndent ? INDENT_DESCRIPTION : DEDENT_DESCRIPTION;\n    return new Failure(this, description, 'description');\n  }\n}\n\n// Create a new definition for `any` that can consume indent & dedent.\nconst applyIndent = new pexprs.Apply('indent');\nconst applyDedent = new pexprs.Apply('dedent');\nconst newAnyBody = new pexprs.Splice(BuiltInRules, 'any', [applyIndent, applyDedent], []);\n\nexport const IndentationSensitive = new Builder()\n    .newGrammar('IndentationSensitive')\n    .withSuperGrammar(BuiltInRules)\n    .define('indent', [], new Indentation(true), INDENT_DESCRIPTION, undefined, true)\n    .define('dedent', [], new Indentation(false), DEDENT_DESCRIPTION, undefined, true)\n    .extend('any', [], newAnyBody, 'any character', undefined)\n    .build();\n\nObject.assign(IndentationSensitive, {\n  _matchStateInitializer(state) {\n    state.userData = findIndentation(state.input);\n    state.inputStream = new InputStreamWithIndentation(state);\n  },\n  supportsIncrementalParsing: false,\n});\n","import ohmGrammar from '../dist/ohm-grammar.js';\nimport {buildGrammar} from './buildGrammar.js';\nimport * as common from './common.js';\nimport * as errors from './errors.js';\nimport {Grammar} from './Grammar.js';\nimport * as pexprs from './pexprs.js';\nimport * as util from './util.js';\n\n// Late initialization for stuff that is bootstrapped.\n\nimport './semanticsDeferredInit.js'; // TODO: Clean this up.\nGrammar.initApplicationParser(ohmGrammar, buildGrammar);\n\nconst isBuffer = obj =>\n  !!obj.constructor &&\n  typeof obj.constructor.isBuffer === 'function' &&\n  obj.constructor.isBuffer(obj);\n\nfunction compileAndLoad(source, namespace) {\n  const m = ohmGrammar.match(source, 'Grammars');\n  if (m.failed()) {\n    throw errors.grammarSyntaxError(m);\n  }\n  return buildGrammar(m, namespace);\n}\n\nexport function grammar(source, optNamespace) {\n  const ns = grammars(source, optNamespace);\n\n  // Ensure that the source contained no more than one grammar definition.\n  const grammarNames = Object.keys(ns);\n  if (grammarNames.length === 0) {\n    throw new Error('Missing grammar definition');\n  } else if (grammarNames.length > 1) {\n    const secondGrammar = ns[grammarNames[1]];\n    const interval = secondGrammar.source;\n    throw new Error(\n        util.getLineAndColumnMessage(interval.sourceString, interval.startIdx) +\n        'Found more than one grammar definition -- use ohm.grammars() instead.',\n    );\n  }\n  return ns[grammarNames[0]]; // Return the one and only grammar.\n}\n\nexport function grammars(source, optNamespace) {\n  const ns = Object.create(optNamespace || {});\n  if (typeof source !== 'string') {\n    // For convenience, detect Node.js Buffer objects and automatically call toString().\n    if (isBuffer(source)) {\n      source = source.toString();\n    } else {\n      throw new TypeError(\n          'Expected string as first argument, got ' + common.unexpectedObjToString(source),\n      );\n    }\n  }\n  compileAndLoad(source, ns);\n  return ns;\n}\n\n// This is used by ohm-editor to instantiate grammars after incremental\n// parsing, which is not otherwise supported in the public API.\nexport {buildGrammar as _buildGrammar};\n\nexport * from './main-kernel.js';\nexport {IndentationSensitive as ExperimentalIndentationSensitive} from './IndentationSensitive.js';\nexport {ohmGrammar};\nexport {pexprs};\nexport {version} from './version.js';\n","// Stuff in here used to be in the standard library of signals -- see msynth-lib.ts\n// But inlining them makes things more efficient b/c we don't have to pay for the\n// overhead of lots of intermediate signals. (It matters for complex patches!)\n\nexport const inlinedFunctions: Record<string, Function> = {\n  // ----- math stuff -----\n  'unary-': (x: string) => `(-${x})`,\n  '+': (x: string, y: string) => `(${x} + ${y})`,\n  '-': (x: string, y: string) => `(${x} - ${y})`,\n  '*': (x: string, y: string) => `(${x} * ${y})`,\n  '/': (x: string, y: string) => `(${x} / ifZero(${y}, 0.00001))`,\n  '%': (x: string, y: string) => `(${x} % ifZero(${y}, 0.00001))`,\n  clamp: (x: string, min: string, max: string) => `Math.min(Math.max(${x}, ${min}), ${max})`,\n  min: (x: string, y: string) => `Math.min(${x}, ${y})`,\n  max: (x: string, y: string) => `Math.max(${x}, ${y})`,\n  round: (x: string) => `Math.round(${x})`,\n  abs: (x: string) => `Math.abs(${x})`,\n  sqrt: (x: string) => `Math.sqrt(${x})`,\n\n  // ----- scaling -----\n\n  /** [min, max] -> [0, 1], linearly */\n  norm: (value: string, min = '-1', max = '1') =>\n    `((value, min, max) => max <= min ? 0 : (value - min) / (max - min))(${value}, ${min}, ${max})`,\n\n  /** [0, 1] -> [min, max], linearly */\n  scale: (value: string, min: string, max: string) =>\n    `((value, min, max) => value * (max - min) + min)(${value}, ${min}, ${max})`,\n\n  /** [0, 1] -> [min, max], exponentially */\n  escale: (s: string, min: string, max: string) =>\n    `((value, min, max) => {\n      if (min === 0) {\n        min = 0.001;\n      }\n      return min * Math.pow(max / min, value);\n    })(${s}, ${min}, ${max})`,\n\n  // ----- frequency helpers -----\n  semitones: (n: string) => `Math.pow(2, ${n} / 12)`,\n  quantizeFreq: (f: string, b = '440') =>\n    `((f, b) => (b * Math.pow(2, Math.round(12 * Math.log2(f / b)) / 12)))(${f}, ${b})`,\n\n  // ----- conditionals -----\n  ifPos: (s: string, t: string, f: string) => `(${s} >= 0 ? ${t} : ${f})`,\n  switch: (s: string, neg: string, zero: string, pos: string) =>\n    `((s, neg, zero, pos) => s === 0 ? zero : s < 0 ? neg : pos)(${s}, ${neg}, ${zero}, ${pos})`,\n\n  // ----- effects -----\n  softClip: (s: string) => `((s) => s <= -1 ? -2/3 : s >= 1 ? 2/3 : s - s ** 3 / 3)(${s})`,\n};\n","import { Signal } from './signal';\n\nexport const builtInSignals = {\n  noise: () => Signal.new(() => Math.random() * 2 - 1),\n  pinkNoise: () => {\n    const BUFFER_SIZE = 16;\n    const buffer = new Array(BUFFER_SIZE).fill(0);\n    let sum = 0;\n    let idx = 0;\n    return Signal.new(() => {\n      sum -= buffer[idx];\n      buffer[idx] = 2 * Math.random() - 1;\n      sum += buffer[idx];\n      idx = (idx + 1) % BUFFER_SIZE;\n      return sum / BUFFER_SIZE;\n    });\n  },\n  noteFreq: () => Signal.new((synth) => synth.noteFreq * Math.pow(2, synth.params[0] / 12)),\n  noteVel: () => Signal.new((synth) => synth.noteVel),\n};\n","export const SAMPLE_RATE = 48_000;\nexport const SAMPLE_RATE_RECIP = 1 / SAMPLE_RATE;\nexport const TAU = 2 * Math.PI;\n","import { SAMPLE_RATE, SAMPLE_RATE_RECIP } from './constants';\nimport { Signal } from './signal';\n\nexport function ad(a: Signal, d: Signal) {\n  let stage: 'off' | 'a' | 'd' = 'off';\n  let value = 0;\n  return Signal.new({\n    nextSample() {\n      switch (stage) {\n        case 'off':\n          return 0;\n        case 'a':\n          value = a.value > 0 ? Math.min(value + SAMPLE_RATE_RECIP / a.value, 1) : 1;\n          if (value === 1) {\n            stage = 'd';\n          }\n          return value;\n        case 'd':\n          value = d.value > 0 ? Math.max(value - SAMPLE_RATE_RECIP / d.value, 0) : 0;\n          if (value === 0) {\n            stage = 'off';\n          }\n          return value;\n      }\n    },\n\n    initialValue: 0,\n\n    noteOn() {\n      stage = 'a';\n      // note: don't set the value to zero, otherwise we get clicks\n      // when the env is triggered halfway through the previous time\n    },\n  });\n}\n\nexport function adsr(a: Signal, d: Signal, s: Signal, r: Signal) {\n  let stage: 'off' | 'a' | 'd' | 's' | 'r' = 'off';\n  let value = 0;\n  return Signal.new({\n    nextSample() {\n      switch (stage) {\n        case 'off':\n          return 0;\n        case 'a':\n          value = a.value > 0 ? Math.min(value + SAMPLE_RATE_RECIP / a.value, 1) : 1;\n          if (value === 1) {\n            stage = 'd';\n          }\n          return value;\n        case 'd':\n          value = d.value > 0 ? Math.max(value - SAMPLE_RATE_RECIP / d.value, s.value) : s.value;\n          if (value === s.value) {\n            stage = 's';\n          }\n          return value;\n        case 's':\n          return value;\n        case 'r':\n          value = r.value > 0 ? Math.max(value - SAMPLE_RATE_RECIP / r.value, 0) : 0;\n          if (value === 0) {\n            stage = 'off';\n          }\n          return value;\n      }\n    },\n\n    initialValue: 0,\n\n    noteOn() {\n      stage = 'a';\n      // note: don't set the value to zero, otherwise we get clicks\n      // when the env is triggered halfway through the previous time\n    },\n\n    noteOff() {\n      stage = 'r';\n    },\n  });\n}\n\nexport function gate(t?: Signal) {\n  let stage: 'on' | 'off' = 'off';\n  let count = 0;\n  return Signal.new({\n    nextSample() {\n      switch (stage) {\n        case 'off':\n          return 0;\n        case 'on':\n          if (t && count++ >= t.value * SAMPLE_RATE) {\n            stage = 'off';\n            return 0;\n          }\n          return 1;\n      }\n    },\n\n    initialValue: 0,\n\n    noteOn() {\n      stage = 'on';\n      count = 0;\n    },\n\n    noteOff() {\n      if (!t) {\n        stage = 'off';\n      }\n    },\n  });\n}\n","import { SAMPLE_RATE, SAMPLE_RATE_RECIP } from './constants';\nimport { Signal } from './signal';\n\n/** glide linearly (t is time for the signal to move 1 unit) */\nexport function linear(input: Signal, t: Signal) {\n  let lastValue = input.value;\n  return Signal.new(() => {\n    if (t.value === 0) {\n      lastValue = input.value;\n    } else {\n      const epsilon = SAMPLE_RATE_RECIP / t.value;\n      const diff = input.value - lastValue;\n      if (diff > epsilon) {\n        lastValue += epsilon;\n      } else if (diff < -epsilon) {\n        lastValue -= epsilon;\n      } else {\n        lastValue = input.value;\n      }\n    }\n    return lastValue;\n  });\n}\n\n/** glide exponentially (t is time for the signal to move 1 octave) */\nexport function exponential(input: Signal, t: Signal, legato: boolean) {\n  let lastValue = input.value;\n  let jumping = false;\n  return Signal.new({\n    nextSample() {\n      if (t.value === 0) {\n        lastValue = input.value;\n      } else if (jumping) {\n        lastValue = input.value;\n        jumping = false;\n      } else {\n        const m = Math.pow(2, 1 / (t.value * SAMPLE_RATE));\n        if (lastValue < input.value) {\n          lastValue = Math.min(lastValue * m, input.value);\n        } else if (lastValue > input.value) {\n          lastValue = Math.max(lastValue / m, input.value);\n        }\n      }\n      return lastValue;\n    },\n\n    initialValue: lastValue,\n\n    noteOn(voice, retriggered) {\n      if (legato && !retriggered && voice.noteNums.length === 1) {\n        jumping = true;\n      }\n    },\n  });\n}\n","export function toFrequency(midiNote: number) {\n  return 440 * Math.pow(2, (midiNote - 69) / 12);\n}\n\n// adapted from https://github.com/pichenettes/stmlib/blob/master/dsp/dsp.h\nexport function interpolatedRead(xs: Float32Array, idx: number) {\n  const whole = Math.floor(idx);\n  const frac = idx - whole;\n  const xm1 = xs[whole - 1 < 0 ? xs.length - 1 : whole - 1];\n  const x0 = xs[whole];\n  const x1 = xs[(whole + 1) % xs.length];\n  const x2 = xs[(whole + 2) % xs.length];\n  const c = (x1 - xm1) / 2;\n  const v = x0 - x1;\n  const w = c + v;\n  const a = w + v + (x2 - x0) / 2;\n  const bNeg = w + a;\n  return ((a * frac - bNeg) * frac + c) * frac + x0;\n}\n\nexport function fastTanh(x: number) {\n  if (x > 3) {\n    return 1;\n  } else if (x < -3) {\n    return -1;\n  } else {\n    const x2 = x * x;\n    return (x * (27 + x2)) / (27 + 9 * x2);\n  }\n}\n\nexport function clamp(v: number, min: number, max: number) {\n  return Math.max(min, Math.min(v, max));\n}\n\nexport function makeSharedFloat32Array(length: number): Float32Array<any> {\n  return new Float32Array(new SharedArrayBuffer(length * 4));\n}\n\nexport class SpeedTracker {\n  readonly windowMs = 150;\n  history: { pos: number; t: number }[] = [];\n\n  addPos(pos: number) {\n    this.history.push({ pos, t: performance.now() });\n  }\n\n  /** the current speed, in pixels per millisecond */\n  get speed() {\n    const now = performance.now();\n    this.history = this.history.filter(({ t }) => now - t <= this.windowMs);\n\n    if (this.history.length < 2) {\n      return 0;\n    }\n\n    let totalDistance = 0;\n    for (let idx = 1; idx < this.history.length; idx++) {\n      totalDistance += Math.abs(this.history[idx].pos - this.history[idx - 1].pos);\n    }\n\n    const dt = this.history[this.history.length - 1].t - this.history[0].t;\n    return totalDistance / dt;\n  }\n}\n","import { SAMPLE_RATE } from './constants';\nimport { Signal } from './signal';\nimport { interpolatedRead } from './helpers';\n\nconst MAX_DELAY_SECONDS = 10;\nconst DELAY_BUFFER_SIZE = MAX_DELAY_SECONDS * SAMPLE_RATE;\n\n// TODO: add support for multiple taps\n// maybe delay(signal, t1, v1, t2, v2, ...)\nexport function delay(input: Signal, t: Signal) {\n  const bufferSize = DELAY_BUFFER_SIZE;\n  const buffer = new Float32Array(bufferSize);\n  let writePos = 0;\n  return Signal.new(() => {\n    let readPos = writePos - Math.min(t.value, MAX_DELAY_SECONDS) * SAMPLE_RATE;\n    if (readPos < 0) {\n      readPos += bufferSize;\n    }\n    buffer[writePos++] = input.value;\n    if (writePos >= bufferSize) {\n      writePos = 0;\n    }\n    return interpolatedRead(buffer, readPos);\n  });\n}\n","// Ported from Daisy's ladder filter\n// https://github.com/electro-smith/DaisySP/blob/master/Source/Filters/ladder.h\n// https://github.com/electro-smith/DaisySP/blob/master/Source/Filters/ladder.cpp\n\nimport { SAMPLE_RATE, TAU } from './constants';\nimport { Signal } from './signal';\nimport { clamp, fastTanh } from './helpers';\n\nconst INTERPOLATION = 4;\nconst INTERPOLATION_RECIP = 1.0 / INTERPOLATION;\nconst SAMPLE_RATE_INTERPOLATION_RECIP = 1 / (SAMPLE_RATE * INTERPOLATION);\nconst RESONANCE_MULTIPLIER = 1.8; // to go from our range of 0 ... 1 to theirs of 0 ... 1.8\nconst MIN_CUTOFF_FREQ = 5;\nconst MAX_CUTOFF_FREQ = SAMPLE_RATE * 0.425;\nconst INPUT_THRESHOLD = 1e-5; // threshold below which we consider input to be zero\nconst STATE_DECAY = 0.95; // decay filter state when input is zero\n\nexport function ladder(\n  mode: 'lp24' | 'lp12' | 'bp24' | 'bp12' | 'hp24' | 'hp12',\n  _input: Signal,\n  _cutoffFreq: Signal,\n  _q: Signal,\n) {\n  let z0 = [0, 0, 0, 0];\n  let z1 = [0, 0, 0, 0];\n  let alpha = 1;\n  let k = 1;\n  let qAdjust = 1;\n  let pbg = 0; // 0 ... 0.5\n  let drive = 1;\n  let driveScaled = 1;\n  let oldInput = 0;\n\n  function updateFreq() {\n    // recompute the coefficients\n    const wc =\n      clamp(_cutoffFreq.value, MIN_CUTOFF_FREQ, MAX_CUTOFF_FREQ) *\n      TAU *\n      SAMPLE_RATE_INTERPOLATION_RECIP;\n    const wc2 = wc * wc;\n    const wc3 = wc * wc2;\n    const wc4 = wc * wc3;\n    alpha = 0.9892 * wc - 0.4324 * wc2 + 0.1381 * wc3 - 0.0202 * wc4;\n    qAdjust = 1.006 + 0.0536 * wc - 0.095 * wc2 - 0.05 * wc4;\n  }\n\n  function updateResonance() {\n    k = 4 * clamp(_q.value, 0, 1) * RESONANCE_MULTIPLIER;\n  }\n\n  // valid range: [0, 4]\n  function setInputDrive(odrv: number) {\n    drive = Math.max(odrv, 0);\n    if (drive > 1) {\n      drive = Math.min(drive, 4);\n      // max is 4 when pbg = 0, and 2.5 when pbg is 0.5\n      driveScaled = 1 + (drive - 1) * (1 - pbg);\n    } else {\n      driveScaled = drive;\n    }\n  }\n\n  function setPassbandGain(value: number) {\n    pbg = clamp(value, 0, 0.5);\n    setInputDrive(drive);\n  }\n\n  function lpf(s: number, idx: number) {\n    //           (1.0 / 1.3)  (0.3 / 1.3)\n    let ft = s * 0.76923077 + 0.23076923 * z0[idx] - z1[idx];\n    ft = ft * alpha + z1[idx];\n    z1[idx] = ft;\n    z0[idx] = s;\n    return ft;\n  }\n\n  // Weighted filter stage mixing to achieve selected response\n  // as described in \"Oscillator and Filter Algorithms for Virtual Analog Synthesis\"\n  // Välimäki and Huovilainen, Computer Music Journal, vol 60, 2006\n  function weightedSumForCurrentMode(\n    stageOuts0: number,\n    stageOuts1: number,\n    stageOuts2: number,\n    stageOuts3: number,\n    stageOuts4: number,\n  ) {\n    switch (mode) {\n      case 'lp24':\n        return stageOuts4;\n      case 'lp12':\n        return stageOuts2;\n      case 'bp24':\n        return (stageOuts2 + stageOuts4) * 4 - stageOuts3 * 8;\n      case 'bp12':\n        return (stageOuts1 - stageOuts2) * 2;\n      case 'hp24':\n        return stageOuts0 + stageOuts4 - (stageOuts1 + stageOuts3) * 4 + stageOuts2 * 6;\n      case 'hp12':\n        return stageOuts0 + stageOuts2 - stageOuts1 * 2;\n      default:\n        return 0;\n    }\n  }\n\n  // initialization\n  // (no need to init freq and resonance b/c those are dealt with for every sample)\n  setInputDrive(1);\n  setPassbandGain(0.5);\n\n  return Signal.new(() => {\n    updateFreq();\n    updateResonance();\n\n    let input = _input.value * driveScaled;\n    const inputAbs = Math.abs(input);\n\n    // If input is effectively zero, decay the filter state to prevent ringing\n    if (inputAbs < INPUT_THRESHOLD) {\n      for (let i = 0; i < 4; i++) {\n        z0[i] *= STATE_DECAY;\n        z1[i] *= STATE_DECAY;\n      }\n      oldInput *= STATE_DECAY;\n    }\n\n    let total = 0;\n    let interp = 0;\n    for (let os = 0; os < INTERPOLATION; os++) {\n      const inInterp = interp * oldInput + (1 - interp) * input;\n      const u = fastTanh(inInterp - (z1[3] - pbg * inInterp) * k * qAdjust);\n      const stage1 = lpf(u, 0);\n      const stage2 = lpf(stage1, 1);\n      const stage3 = lpf(stage2, 2);\n      const stage4 = lpf(stage3, 3);\n      total += weightedSumForCurrentMode(u, stage1, stage2, stage3, stage4) * INTERPOLATION_RECIP;\n      interp += INTERPOLATION_RECIP;\n    }\n    oldInput = input;\n    return total;\n  });\n}\n","import { Signal, scalar } from './signal';\nimport * as env from './env';\nimport * as glide from './glide';\nimport * as effects from './effects';\nimport { ladder } from './ladder';\nimport { SAMPLE_RATE_RECIP, TAU } from './constants';\n\n// TODO: functions here should do arity checking\n// i.e., they should throw an error if they received too few or too many args\n// This prob. means that they should take an Ohm interval as their 1st arg.\n\nexport const msynthLib: Record<string, Function> = {\n  // ----- oscillators -----\n\n  sine: (f = scalar(440)) => {\n    let phase = 0;\n    return Signal.new(() => {\n      const sample = Math.sin(phase * TAU);\n      const phaseInc = f.value * SAMPLE_RATE_RECIP;\n      phase += phaseInc;\n      phase -= Math.floor(phase);\n      return sample;\n    });\n  },\n\n  saw(f = scalar(440)) {\n    let phase = 0;\n    return Signal.new(() => {\n      const naiveSample = 2 * phase - 1;\n      const phaseInc = f.value * SAMPLE_RATE_RECIP;\n      const sample = naiveSample - polyBlep(phase, phaseInc);\n      phase += phaseInc;\n      phase -= Math.floor(phase);\n      return sample;\n    });\n  },\n\n  tri(f = scalar(440)) {\n    let phase = 0;\n    let integrator = 0;\n    return Signal.new(() => {\n      const phaseInc = f.value * SAMPLE_RATE_RECIP;\n      const square =\n        (phase >= 0.25 && phase < 0.75 ? -1.0 : 1.0) -\n        polyBlep((phase + 0.75) % 1, phaseInc) +\n        polyBlep((phase + 0.25) % 1, phaseInc);\n      integrator = 0.999 * integrator + square * phaseInc * 4;\n      phase += phaseInc;\n      phase -= Math.floor(phase);\n      return integrator;\n    });\n  },\n\n  pulse: (f = scalar(440), m = scalar(0.5), sync: Signal | null = null) => {\n    let phase = 0;\n    let prevSyncValue = 0;\n    return Signal.new(() => {\n      const naiveSample = phase < m.value ? -1 : 1;\n      const phaseInc = f.value * SAMPLE_RATE_RECIP;\n      const sample =\n        naiveSample - polyBlep(phase, phaseInc) + polyBlep((phase - m.value + 1) % 1, phaseInc);\n\n      const currSyncValue = sync?.value ?? 0;\n      let syncDetected = false;\n      if (prevSyncValue < 0 && currSyncValue >= 0) {\n        const currSyncValue = sync?.value ?? 0;\n        if (prevSyncValue < 0 && currSyncValue >= 0) {\n          // estimate zero crossing between previous and current value\n          // prev + (curr - prev) * r = 0  =>  r = -prev / (curr - prev)\n          const r = -prevSyncValue / (currSyncValue - prevSyncValue);\n          // time since crossing to current sample = (1 - r) * dt\n          phase = Math.floor((1 - r) * phaseInc);\n          syncDetected = true;\n        }\n      }\n      prevSyncValue = currSyncValue;\n\n      if (!syncDetected) {\n        phase += phaseInc;\n        phase -= Math.floor(phase);\n      }\n      return sample;\n    });\n  },\n\n  // ----- glides -----\n\n  // TODO: consider adding lag(s: Signal, t: Signal) -- lag processor\n\n  /** glide linearly (t is time for the signal to move 1 unit) */\n  lglide: (s: Signal, t = scalar(0.1)) => glide.linear(s, t),\n\n  /** glide exponentially (t is time for the signal to move 1 octave, in seconds) */\n  eglide: (s: Signal, t = scalar(1)) => glide.exponential(s, t, false),\n\n  legato: (s: Signal, t = scalar(1)) => glide.exponential(s, t, true),\n\n  // ----- envelopes -----\n\n  // TODO: in the 2600, the vca has a linear/exponential switch.\n  // look at that and think about it -- maybe there are better building blocks for us?\n\n  ad: env.ad,\n  adsr: env.adsr,\n  gate: env.gate,\n\n  // ----- filters -----\n  lpf: (s: Signal, cf: Signal, q = scalar(0.2)) => ladder('lp24', s, cf, q),\n  lpf12: (s: Signal, cf: Signal, q = scalar(0.2)) => ladder('lp12', s, cf, q),\n  lpf24: (s: Signal, cf: Signal, q = scalar(0.2)) => ladder('lp24', s, cf, q),\n  hpf: (s: Signal, cf: Signal, q = scalar(0.2)) => ladder('hp24', s, cf, q),\n  hpf12: (s: Signal, cf: Signal, q = scalar(0.2)) => ladder('hp12', s, cf, q),\n  hpf24: (s: Signal, cf: Signal, q = scalar(0.2)) => ladder('hp24', s, cf, q),\n  bpf: (s: Signal, cf: Signal, q = scalar(0.2)) => ladder('bp24', s, cf, q),\n  bpf12: (s: Signal, cf: Signal, q = scalar(0.2)) => ladder('bp12', s, cf, q),\n  bpf24: (s: Signal, cf: Signal, q = scalar(0.2)) => ladder('bp24', s, cf, q),\n\n  // ----- effects -----\n  delay: effects.delay,\n\n  // ----- other helpers -----\n\n  // TODO: change to sampleAndHold(s: Signal, clock: Signal), trigger on upward zero-crossing\n  // (in the arp 2600, the noise generator is hard-wired as the input by default)\n\n  latch: (s: Signal, useLastValue: Signal) => {\n    let lastValue = 0;\n    return Signal.new(() => {\n      if (useLastValue.value === 0) {\n        lastValue = s.value;\n      }\n      return lastValue;\n    });\n  },\n\n  // DC blocking filter: high-pass at ~35Hz to remove DC while preserving audible content\n  // Uses a one-pole high-pass: y[n] = x[n] - x[n-1] + α * y[n-1]\n  dcBlock: (s: Signal) => {\n    // α = 0.995 gives ~35Hz cutoff at 48kHz\n    const alpha = 0.995;\n    let prevX = 0;\n    let prevY = 0;\n    return Signal.new(() => {\n      const x = s.value;\n      const y = x - prevX + alpha * prevY;\n      prevX = x;\n      prevY = y;\n      return y;\n    });\n  },\n};\n\n// https://mitxela.com/projects/bleps_via_state_machine\nfunction polyBlep(t: number, dt: number) {\n  // 0 <= t < 1\n  if (t < dt) {\n    t /= dt;\n    // 2 * (t - t^2/2 - 0.5)\n    return t + t - t * t - 1;\n  }\n\n  // -1 < t < 0\n  if (t > 1 - dt) {\n    t = (t - 1) / dt;\n    // 2 * (t^2/2 + t + 0.5)\n    return t * t + t + t + 1;\n  }\n\n  // 0 otherwise\n  return 0;\n}\n","import * as ohm from 'ohm-js';\nimport { Signal } from './signal';\nimport { inlinedFunctions } from './inlined-functions';\nimport { builtInSignals } from './built-in-signals';\nimport { msynthLib as lib } from './msynth-lib';\nimport { fastTanh } from './helpers';\n\n// TODO: check for mutually-recursive macros!\n// TODO: allow default values for macros' args\n\nexport class CompilerError extends Error {\n  constructor(\n    message: string,\n    readonly interval: ohm.Interval,\n  ) {\n    super(message);\n  }\n}\n\nexport const grammar = ohm.grammar(String.raw`\n  MSynth {\n    Prog = Decl+\n\n    Decl\n      = ident \"=\" Expr                   -- signal\n      | def ident MArgs \"=\" Expr         -- macroCall\n      | def ident ident MArgs? \"=\" Expr  -- macroSend\n\n    Expr = ArrowExpr\n\n    ArrowExpr\n      = ArrowExpr \">>\" ident Args?  -- send\n      | AddExpr\n\n    AddExpr\n      = AddExpr \"+\" MulExpr  -- plus\n      | AddExpr \"-\" MulExpr  -- minus\n      | MulExpr\n\n    MulExpr\n      = MulExpr \"*\" NegExpr  -- times\n      | MulExpr \"/\" NegExpr  -- div\n      | MulExpr \"%\" NegExpr  -- mod\n      | NegExpr\n\n    NegExpr\n      = \"-\" NegExpr  -- neg\n      | SendExpr\n\n    SendExpr\n      = SendExpr ~(ident \"=\") ident Args?  -- send\n      | PriExpr\n\n    PriExpr\n      = ident Args    -- call\n      | ident         -- ref\n      | number        -- num\n      | \"(\" Expr \")\"  -- par\n\n    Args = \"(\" ListOf<Expr, \",\"> \")\"\n\n    MArgs = \"(\" ListOf<ident, \",\"> \")\"\n\n    ident  (an identifier)\n      = ~keyword \"$\"? letter alnum*\n\n    number  (a number)\n      = digit* \".\" digit+  -- fract\n      | digit+             -- whole\n\n    keyword = def | this\n    def = \"def\" ~alnum\n    this = \"this\" ~alnum\n\n    space += \"//\" (~\"\\n\" any)*  -- comment\n  }\n`);\n\ninterface RefInfo {\n  params: number[];\n  builtins: string[];\n}\n\nabstract class ANode {\n  constructor(readonly interval: ohm.Interval) {}\n  abstract addRefs(refs: Set<string>): void;\n}\n\nclass Prog extends ANode {\n  constructor(\n    readonly decls: (SDecl | MDecl)[],\n    interval: ohm.Interval,\n  ) {\n    super(interval);\n  }\n\n  checkDuplicateDeclarations() {\n    const declared = new Set<string>();\n    for (const d of this.mdecls) {\n      if (declared.has(d.name)) {\n        throw new CompilerError(`duplicate declaration of macro ${d.name}`, d.interval);\n      }\n      declared.add(d.name);\n    }\n\n    declared.clear();\n    for (const d of this.sdecls) {\n      if (declared.has(d.name)) {\n        throw new CompilerError(`duplicate declaration of signal ${d.name}`, d.interval);\n      }\n      declared.add(d.name);\n    }\n  }\n\n  checkCalls(inlinedFunctions: Record<string, Function>, lib: Record<string, Function>) {\n    for (const decl of this.decls) {\n      decl.checkCalls(this.mdecls, inlinedFunctions, lib);\n    }\n  }\n\n  checkRefs(\n    builtInSignals: Record<string, () => Signal>,\n    paramNames: Map<string, number>,\n  ): RefInfo {\n    const refs = new Set<string>();\n    this.addRefs(refs);\n\n    const params = new Set<number>();\n    const builtins = new Set<string>();\n    for (const name of refs) {\n      const n = getParamNum(name);\n      if (n !== null) {\n        params.add(n);\n      } else if (paramNames.has(name)) {\n        params.add(paramNames.get(name)!);\n      } else if (builtInSignals.hasOwnProperty(name)) {\n        builtins.add(name);\n      } else if (!this.decls.some((d) => d.name === name)) {\n        throw new CompilerError(`undeclared reference: ${name}`, this.interval);\n      }\n    }\n\n    return {\n      params: [...params],\n      builtins: [...builtins],\n    };\n  }\n\n  override addRefs(refs: Set<string>) {\n    for (const decl of this.decls) {\n      decl.addRefs(refs);\n    }\n  }\n\n  get sdecls() {\n    return this.decls.filter((d) => d instanceof SDecl);\n  }\n\n  get mdecls() {\n    return this.decls.filter((d) => d instanceof MDecl);\n  }\n\n  trans(\n    refs: RefInfo,\n    inlinedFunctions: Record<string, Function>,\n    paramNames: Map<string, number>,\n  ): string {\n    const haveSignal = (name: string) => this.sdecls.some((d) => d.name === name);\n    let outputs: string[];\n    if (haveSignal('left') && haveSignal('right')) {\n      outputs = ['__left', '__right'];\n    } else if (haveSignal('out')) {\n      outputs = ['__out'];\n    } else {\n      outputs = ['Signal.scalar(0)'];\n    }\n    return `(() => {\n      ${refs.params.map((n) => `const __param${n} = Signal.new((synth) => synth.params[${n}]);`).join('\\n')}\n      ${[...paramNames.entries()]\n        .filter(([name, n]) => refs.params.includes(n))\n        .map(([name, n]) => `const __${name} = __param${n};`)\n        .join('\\n')}\n      ${refs.builtins.map((name) => `const __${name} = __.${name}();`).join('\\n')}\n      ${this.sdecls.map((d) => `let __${d.name};`).join('\\n')}\n      ${this.sdecls.map((d) => d.trans(this.mdecls, inlinedFunctions)).join('\\n')}\n      ${this.sdecls.map((d) => `__${d.name} = __${d.name}.force();`).join('\\n')}\n      return [${outputs.join(', ')}];\n    })()`;\n  }\n}\n\nabstract class ADecl extends ANode {\n  constructor(\n    readonly name: string,\n    readonly rhs: AExpr,\n    interval: ohm.Interval,\n  ) {\n    super(interval);\n  }\n\n  checkCalls(\n    mdecls: MDecl[],\n    inlinedFunctions: Record<string, Function>,\n    lib: Record<string, Function>,\n  ) {\n    this.rhs.checkCalls(mdecls, inlinedFunctions, lib);\n  }\n}\n\nclass SDecl extends ADecl {\n  constructor(name: string, rhs: AExpr, interval: ohm.Interval) {\n    super(name, rhs, interval);\n  }\n\n  override addRefs(refs: Set<string>) {\n    this.rhs.addRefs(refs);\n  }\n\n  trans(mdecls: MDecl[], inlinedFunctions: Record<string, Function>) {\n    const signals: string[] = [];\n    const expr = this.rhs.trans('signal', signals, mdecls, inlinedFunctions);\n    const signal =\n      signals.length === 0\n        ? expr\n        : `{\n      ${signals.map((code, idx) => `const tmp${idx} = ${code};`).join('\\n')}\n      return ${expr};\n    }`;\n    return `__${this.name} = lazy(() => ${signal});`;\n  }\n}\n\nclass MDecl extends ADecl {\n  constructor(\n    name: string,\n    readonly argNames: string[],\n    rhs: AExpr,\n    interval: ohm.Interval,\n  ) {\n    super(name, rhs, interval);\n  }\n\n  override addRefs(refs: Set<string>) {\n    const localRefs = new Set<string>();\n    this.rhs.addRefs(localRefs);\n    for (const argName of this.argNames) {\n      localRefs.delete(argName);\n    }\n    for (const r of localRefs) {\n      refs.add(r);\n    }\n  }\n\n  expand(call: Call): AExpr {\n    if (call.args.length !== this.argNames.length) {\n      throw new CompilerError(\n        `wrong number of arguments passed to macro ${this.name}: expected ${this.argNames.length}, got ${call.args.length}`,\n        call.interval,\n      );\n    }\n    const subst = new Map<string, AExpr>();\n    for (let idx = 0; idx < this.argNames.length; idx++) {\n      subst.set(this.argNames[idx], call.args[idx]);\n    }\n    return this.rhs.apply(subst);\n  }\n}\n\nabstract class AExpr extends ANode {\n  constructor(\n    interval: ohm.Interval,\n    readonly children: AExpr[] = [],\n  ) {\n    super(interval);\n  }\n\n  checkCalls(\n    mdecls: MDecl[],\n    inlinedFunctions: Record<string, Function>,\n    lib: Record<string, Function>,\n  ) {\n    for (const child of this.children) {\n      child.checkCalls(mdecls, inlinedFunctions, lib);\n    }\n  }\n\n  override addRefs(refs: Set<string>) {\n    for (const child of this.children) {\n      child.addRefs(refs);\n    }\n  }\n\n  abstract apply(subst: Map<string, AExpr>): AExpr;\n\n  abstract trans(\n    want: 'number' | 'signal',\n    signals: string[],\n    mdecls: MDecl[],\n    inlinedFunctions: Record<string, Function>,\n  ): string;\n}\n\nclass Call extends AExpr {\n  constructor(\n    readonly name: string,\n    readonly args: AExpr[],\n    interval: ohm.Interval,\n  ) {\n    super(interval, args);\n  }\n\n  override checkCalls(\n    mdecls: MDecl[],\n    inlinedFunctions: Record<string, Function>,\n    lib: Record<string, Function>,\n  ) {\n    super.checkCalls(mdecls, inlinedFunctions, lib);\n\n    const isDeclared =\n      mdecls.some((d) => d.name === this.name) ||\n      inlinedFunctions.hasOwnProperty(this.name) ||\n      lib.hasOwnProperty(this.name);\n    if (!isDeclared) {\n      throw new CompilerError(`undeclared function: ${this.name}`, this.interval);\n    }\n  }\n\n  override apply(subst: Map<string, AExpr>) {\n    return new Call(\n      this.name,\n      this.args.map((arg) => arg.apply(subst)),\n      this.interval,\n    );\n  }\n\n  override trans(\n    want: 'number' | 'signal',\n    signals: string[],\n    mdecls: MDecl[],\n    inlinedFunctions: Record<string, Function>,\n  ) {\n    const macro = mdecls.find((d) => d.name === this.name);\n    if (macro) {\n      // if it's a macro, expand and translate what comes out\n      return macro.expand(this).trans(want, signals, mdecls, inlinedFunctions);\n    }\n\n    let call: string;\n    if (inlinedFunctions.hasOwnProperty(this.name)) {\n      const args = this.args.map((arg) => arg.trans('number', signals, mdecls, inlinedFunctions));\n      call = inlinedFunctions[this.name](...args);\n      if (want === 'signal') {\n        const idx = signals.length;\n        signals.push(`Signal.new(() => ${call})`);\n        call = `tmp${idx}`;\n      }\n    } else {\n      const args = this.args.map((arg) => arg.trans('signal', signals, mdecls, inlinedFunctions));\n      call = `_.${this.name}(${args.join(', ')})`;\n      const idx = signals.length;\n      signals.push(call);\n      call = `tmp${idx}`;\n      if (want === 'number') {\n        call = `${call}.value`;\n      }\n    }\n    return call;\n  }\n}\n\nclass Ref extends AExpr {\n  constructor(\n    readonly name: string,\n    interval: ohm.Interval,\n  ) {\n    super(interval);\n  }\n\n  override addRefs(refs: Set<string>) {\n    refs.add(this.name);\n  }\n\n  override apply(subst: Map<string, AExpr>): AExpr {\n    return subst.get(this.name) ?? this;\n  }\n\n  override trans(want: 'number' | 'signal', signals: string[]) {\n    const n = getParamNum(this.name);\n    const ref = n !== null ? `__param${n}` : `__${this.name}`;\n    return want === 'signal' ? ref : `${ref}.value`;\n  }\n}\n\nclass ANumber extends AExpr {\n  constructor(\n    readonly value: number,\n    interval: ohm.Interval,\n  ) {\n    super(interval);\n  }\n\n  override apply(subst: Map<string, AExpr>) {\n    return this;\n  }\n\n  override trans(want: 'number' | 'signal') {\n    const number = '' + this.value;\n    return want === 'number' ? number : `Signal.scalar(${number})`;\n  }\n}\n\nfunction getParamNum(name: string) {\n  if (!(name.startsWith('param') && [...name.slice(5)].every((c) => '0' <= c && c <= '9'))) {\n    return null;\n  }\n  const n = parseInt(name.slice(5));\n  return 0 <= n && n <= 127 ? n : null;\n}\n\nconst s = grammar.createSemantics().addOperation<any>('toAst', {\n  Prog(decls) {\n    return new Prog(decls.toAst(), this.source);\n  },\n  Decl_signal(n, _eq, e) {\n    return new SDecl(n.sourceString, e.toAst(), this.source);\n  },\n  Decl_macroCall(_def, n, margs, _eq, e) {\n    return new MDecl(n.sourceString, margs.toAst(), e.toAst(), this.source);\n  },\n  Decl_macroSend(_def, r, n, margs, _eq, e) {\n    return new MDecl(\n      n.sourceString,\n      [r.toAst(), ...(margs.child(0)?.toAst() ?? [])],\n      e.toAst(),\n      this.source,\n    );\n  },\n  ArrowExpr_send(r, _arrow, m, es) {\n    return new Call(m.sourceString, [r.toAst(), ...(es.child(0)?.toAst() ?? [])], this.source);\n  },\n  AddExpr_plus(x, _plus, y) {\n    return new Call('+', [x.toAst(), y.toAst()], this.source);\n  },\n  AddExpr_minus(x, _minus, y) {\n    return new Call('-', [x.toAst(), y.toAst()], this.source);\n  },\n  MulExpr_times(x, _times, y) {\n    return new Call('*', [x.toAst(), y.toAst()], this.source);\n  },\n  MulExpr_div(x, _div, y) {\n    return new Call('/', [x.toAst(), y.toAst()], this.source);\n  },\n  MulExpr_mod(x, _mod, y) {\n    return new Call('%', [x.toAst(), y.toAst()], this.source);\n  },\n  NegExpr_neg(_minus, e) {\n    return new Call('unary-', [e.toAst()], this.source);\n  },\n  SendExpr_send(r, m, es) {\n    return new Call(m.sourceString, [r.toAst(), ...(es.child(0)?.toAst() ?? [])], this.source);\n  },\n  PriExpr_call(n, es) {\n    return new Call(n.sourceString, es.toAst(), this.source);\n  },\n  PriExpr_ref(n) {\n    return new Ref(this.sourceString, this.source);\n  },\n  PriExpr_num(n) {\n    return new ANumber(parseFloat(this.sourceString), this.source);\n  },\n  PriExpr_par(_oparen, e, _cparen) {\n    return e.toAst();\n  },\n  Args(_oparen, es, _cparen) {\n    return es.toAst();\n  },\n  MArgs(_oparen, xs, _cparen) {\n    return xs.toAst();\n  },\n  ident(_optDollar, _first, _rest) {\n    return this.sourceString;\n  },\n  NonemptyListOf(x, _sep, xs) {\n    return [x.toAst()].concat(xs.toAst());\n  },\n  EmptyListOf() {\n    return [];\n  },\n  _iter(...children) {\n    return children.map((c) => c.toAst());\n  },\n});\n\nexport function compile(input: string, paramNames: Map<string, number>): () => Signal[] {\n  const mr = grammar.match(input);\n  if (mr.failed()) {\n    const expected = (mr as any)\n      .getRightmostFailures()\n      .map((f: any) => (f.type === 'string' ? `\"${f.text}\"` : f.text));\n    if (expected.length > 1) {\n      expected[expected.length - 1] = 'or ' + expected[expected.length - 1];\n    }\n    throw new CompilerError(`expected ${expected.join(', ')}`, mr.getInterval());\n  }\n\n  const prog = s(mr).toAst() as Prog;\n  prog.checkDuplicateDeclarations();\n  prog.checkCalls(inlinedFunctions, lib);\n  const refs = prog.checkRefs(builtInSignals, paramNames);\n  const code = prog.trans(refs, inlinedFunctions, paramNames);\n  console.log('compiled code:\\n', code);\n\n  return () => evalCompiledCode(code);\n}\n\nfunction evalCompiledCode(code: string): Signal[] {\n  const _ = Object.create(lib);\n  const __ = builtInSignals;\n  const lazy = (makeSignal: () => Signal) => {\n    let s: Signal | null = null;\n    const force = () => {\n      if (!s) {\n        s = makeSignal();\n      }\n      return s;\n    };\n    const proxy = Signal.new({\n      nextSample: (synth) => force().nextSample(synth),\n      initialValue: 0, // can't call force() here because it may be recursive!\n      noteOn: (voice, retriggered) => force().noteOn?.(voice, retriggered),\n      noteOff: () => force().noteOff?.(),\n    });\n    (proxy as any).force = force;\n    return proxy;\n  };\n  const ifZero = (x: number, y: number) => (x === 0 ? y : x);\n  return new Function('Signal', '_', '__', 'lazy', 'ifZero', 'fastTanh', `return ${code};`)(\n    Signal,\n    _,\n    __,\n    lazy,\n    ifZero,\n    fastTanh,\n  );\n}\n","import { Signal } from './signal';\nimport { toFrequency } from './helpers';\n\nexport class Synth {\n  noteNums: number[] = [];\n  noteNum = 0;\n  noteFreq = 0;\n  noteVel = 0;\n\n  constructor(\n    readonly channel: number,\n    readonly outs: Signal[],\n    readonly allSignals: Signal[],\n    // 0: glide, 1: slide, 2: pressure, 3: paramA, 4: paramB, 5: paramC, 6: paramD, 7: gain\n    readonly params: Float32Array<any>,\n  ) {}\n\n  processMidiMessage([d1, d2, d3]: Uint8Array) {\n    const channel = d1 & 0b1111;\n    if (channel !== this.channel) {\n      return; // this message is not for me, so ignore it\n    }\n\n    switch (d1 >> 4) {\n      case 0b1001: {\n        const note = d2;\n        const velocity = d3;\n        if (velocity === 0) {\n          // some devices send noteOn with vel 0 for noteOff!\n          this.noteOff(note, velocity);\n        } else {\n          this.noteOn(note, velocity);\n        }\n        break;\n      }\n      case 0b1000: {\n        const note = d2;\n        const velocity = d3;\n        this.noteOff(note, velocity);\n        break;\n      }\n    }\n  }\n\n  noteOn(note: number, vel: number) {\n    this.noteNums.push(note);\n    this.noteNum = note;\n    this.noteFreq = toFrequency(note);\n    this.noteVel = vel / 127;\n    this.allSignals.forEach((s) => s.noteOn?.(this, false));\n  }\n\n  noteOff(note: number, vel: number) {\n    const idx = this.noteNums.indexOf(note);\n    const retriggerNext = idx === this.noteNums.length - 1;\n    this.noteNums.splice(idx, 1);\n    const nextNote = this.noteNums.at(-1);\n    if (nextNote != null && retriggerNext) {\n      this.noteNum = nextNote;\n      this.noteFreq = toFrequency(nextNote);\n      this.allSignals.forEach((s) => s.noteOn?.(this, true));\n    } else if (this.noteNums.length === 0) {\n      this.allSignals.forEach((s) => s.noteOff?.());\n    }\n  }\n\n  processFrame(frameIdx: number, output: Float32Array[]) {\n    this.allSignals.forEach((s) => s.computeSample(frameIdx, this));\n    const gain = this.params[7];\n    if (this.outs.length === 2 && output.length >= 2) {\n      // stereo\n      for (let ch = 0; ch < 2; ch++) {\n        const sample = this.outs[ch].value * gain;\n        output[ch][frameIdx] += sample;\n      }\n    } else {\n      // mono\n      const sample = this.outs[0].value * gain;\n      for (let ch = 0; ch < output.length; ch++) {\n        output[ch][frameIdx] += sample;\n      }\n    }\n  }\n}\n","export function noteOn(ch: number, note: number, velocity: number) {\n  return new Uint8Array([0x90 | (ch & 0b1111), note & 0x7f, velocity & 0x7f]);\n}\n\nexport function noteOff(ch: number, note: number, velocity: number) {\n  return new Uint8Array([0x80 | (ch & 0b1111), note & 0x7f, velocity & 0x7f]);\n}\n\nexport function ccChange(ch: number, cc: number, value: number) {\n  return new Uint8Array([0xb0 | (ch & 0b1111), cc & 0x7f, value & 0x7f]);\n}\n\nexport function pitchBend(ch: number, value: number) {\n  const intValue = Math.max(0, Math.min(16383, Math.round(value)));\n  return new Uint8Array([0xe0 | (ch & 0b1111), intValue & 0x7f, (intValue >> 7) & 0x7f]);\n}\n\nexport function pressure(ch: number, value: number) {\n  return new Uint8Array([0xd0 | (ch & 0b1111), value & 0x7f, 0]);\n}\n","import { Signal } from './signal';\nimport { compile } from './compiler';\nimport { MessageFromWorklet, MessageToWorklet } from './types';\nimport { Synth } from './synth';\nimport { noteOff, noteOn } from './midi-message-constructors';\nimport { SAMPLE_RATE } from './constants';\n\nexport class Msynth extends AudioWorkletProcessor implements AudioWorkletProcessorImpl {\n  voiceParams: Float32Array<any>[] = [];\n  voices: Synth[] = [];\n  readonly sequencer = new Sequencer(this);\n\n  constructor() {\n    super();\n    this.port.onmessage = (msg: MessageEvent<MessageToWorklet>) => this.onMessage(msg.data);\n  }\n\n  sendMessage(msg: MessageFromWorklet, transferObjects: Transferable[] = []) {\n    this.port.postMessage(msg, transferObjects);\n  }\n\n  onMessage(msg: MessageToWorklet) {\n    switch (msg.command) {\n      case 'init': {\n        this.voiceParams = msg.voiceParams.map((buffer) => new Float32Array<any>(buffer));\n        break;\n      }\n      case 'load patch': {\n        try {\n          const makeSignals = compile(\n            msg.code,\n            new Map([\n              ['glide', 0],\n              ['slide', 1],\n              ['pressure', 2],\n              ['paramA', 3],\n              ['paramB', 4],\n              ['paramC', 5],\n              ['paramD', 6],\n            ]),\n          );\n          this.voices = [];\n          for (let channel = 0; channel < (msg.mono ? 1 : this.voiceParams.length); channel++) {\n            const allSignals: Signal[] = [];\n            const outs = Signal.doCollectingNewInstances(makeSignals, allSignals);\n            this.voices.push(new Synth(channel, outs, allSignals, this.voiceParams[channel]));\n          }\n        } catch (e: any) {\n          this.sendMessage({ event: 'log', message: `error loading patch: ${e.message}` });\n          console.error(e);\n        }\n        break;\n      }\n      case 'process midi message': {\n        for (let voice of this.voices) {\n          voice.processMidiMessage(msg.data);\n        }\n        break;\n      }\n      case 'load steps': {\n        this.sequencer.load(msg.steps);\n        break;\n      }\n      case 'set tempo': {\n        this.sequencer.setTempo(msg.value);\n        break;\n      }\n      case 'start sequencer': {\n        this.sequencer.start();\n        break;\n      }\n      case 'stop sequencer': {\n        this.sequencer.stop();\n        break;\n      }\n      default: {\n        console.error('unsupported message', msg);\n        throw new Error('unsupported message!');\n      }\n    }\n  }\n\n  process(inputs: Float32Array[][], [output]: Float32Array[][], parameters: any) {\n    this.sequencer.run();\n    const numFrames = output[0].length;\n    for (let frameIdx = 0; frameIdx < numFrames; frameIdx++) {\n      for (const voice of this.voices) {\n        voice.processFrame(frameIdx, output);\n      }\n    }\n    return true;\n  }\n}\n\nclass Sequencer {\n  tempo = 120;\n  triggerPeriod = 1 / 8;\n  noteDuration = 1 / 16;\n  steps: number[][] = [];\n  stepIdx = 0;\n  measuresSinceLastTrigger = Infinity;\n  playing = false;\n\n  constructor(public synth: Msynth) {}\n\n  setTempo(bpm: number) {\n    this.tempo = bpm;\n  }\n\n  load(steps: number[][]) {\n    this.playCurrentStep('noteOff');\n    this.steps = steps;\n    this.stepIdx = 0;\n  }\n\n  start() {\n    this.playing = true;\n    this.stepIdx = 0;\n    this.measuresSinceLastTrigger = Infinity;\n  }\n\n  stop() {\n    this.playCurrentStep('noteOff');\n    this.playing = false;\n  }\n\n  notesAreOn = false;\n  channelsUsed: number[] = [];\n\n  run() {\n    if (!this.playing || this.steps.length === 0) {\n      return;\n    }\n\n    if (this.measuresSinceLastTrigger >= this.triggerPeriod) {\n      this.playCurrentStep('noteOn');\n      this.measuresSinceLastTrigger = 0;\n      this.synth.sendMessage({ event: 'seq step', index: this.stepIdx, action: 'noteOn' });\n      return;\n    }\n\n    if (this.notesAreOn && this.measuresSinceLastTrigger >= this.noteDuration) {\n      this.playCurrentStep('noteOff');\n      this.synth.sendMessage({ event: 'seq step', index: this.stepIdx, action: 'noteOff' });\n      this.stepIdx = (this.stepIdx + 1) % this.steps.length;\n    }\n\n    this.measuresSinceLastTrigger += this.tempo / SAMPLE_RATE;\n  }\n\n  playCurrentStep(action: 'noteOn' | 'noteOff') {\n    const notes = this.steps[this.stepIdx];\n    if (!notes) {\n      return;\n    }\n\n    if (action === 'noteOn') {\n      this.channelsUsed = [];\n      this.notesAreOn = true;\n    } else {\n      this.notesAreOn = false;\n    }\n\n    notes.forEach((note, idx) => {\n      let ch: number;\n      if (action === 'noteOn') {\n        ch = this.nextVoiceIdx();\n        this.channelsUsed.push(ch);\n      } else {\n        ch = this.channelsUsed[idx];\n      }\n      this.synth.voices[ch]?.processMidiMessage(\n        (action === 'noteOn' ? noteOn : noteOff)(ch, note, 127),\n      );\n    });\n  }\n\n  // TODO: be smarter about allocating voices\n  // (Ideally, we should coordinate between here and the UI so that\n  // there is as little voice-stealing as possible when the sequencer\n  // and the user are playing at the same time.)\n  lastVoiceIdx = -1;\n  nextVoiceIdx() {\n    const idx = (this.lastVoiceIdx + 1) % this.synth.voices.length;\n    this.lastVoiceIdx = idx;\n    return idx;\n  }\n}\n\nregisterProcessor('msynth', Msynth);\n"],"names":["Signal","nextSample","value","noteOn","noteOff","writeSharedState","fn","collector","oldCollector","config","frameIdx","synth","scalar","abstract","optMethodName","methodName","assert","cond","message","defineLazyProperty","obj","propName","getterFn","memo","clone","repeatFn","n","arr","repeatStr","str","repeat","x","getDuplicates","array","duplicates","idx","copyWithoutDuplicates","noDuplicates","entry","isSyntactic","ruleName","firstChar","isLexical","padLeft","len","optChar","ch","StringBuffer","escapeUnicode","unescapeCodePoint","s","unexpectedObjToString","baseToString","typeName","checkNotNull","UnicodeCategories","PExpr","interval","any","end","Terminal","Range","from","to","Param","index","Alt","terms","Extend","superGrammar","name","body","origBody","Splice","beforeTerms","afterTerms","Seq","factors","Iter","expr","Star","Plus","Opt","Not","Lookahead","Lex","Apply","args","common.isSyntactic","UnicodeChar","category","createError","optInterval","e","intervalSourcesDontMatch","grammarSyntaxError","matchFailure","undeclaredGrammar","grammarName","namespace","duplicateGrammarDeclaration","grammar","grammarDoesNotSupportIncrementalParsing","undeclaredRule","cannotOverrideUndeclaredRule","optSource","cannotExtendUndeclaredRule","duplicateRuleDeclaration","declGrammarName","wrongNumberOfParameters","expected","actual","source","wrongNumberOfArguments","duplicateParameterNames","invalidParameter","syntacticVsLexicalNote","applicationOfSyntacticRuleFromLexicalContext","applyExpr","applySyntacticWithLexicalRuleApplication","unnecessaryExperimentalApplySyntactic","incorrectArgumentType","expectedType","multipleSuperSplices","invalidCodePoint","applyWrapper","node","digitIntervals","d","fullInterval","kleeneExprHasNullableOperand","kleeneExpr","applicationStack","actuals","stackTrace","app","pexprs.Apply","inconsistentArity","multipleErrors","errors","messages","missingSemanticAction","ctorName","type","stack","info","ans","moreInfo","throwErrors","padNumbersToEqualLength","maxLen","common.padLeft","strcpy","dest","src","offset","origDestLen","start","lineAndColumnToMessage","ranges","lineAndCol","common","sb","common.StringBuffer","lineNumbers","appendLine","num","content","prefix","lineLen","indicationLine","i","startIdx","endIdx","common.assert","lineStartOffset","gutterWidth","builtInRulesCallbacks","awaitBuiltInRules","cb","announceBuiltInRules","getLineAndColumn","lineNum","colNum","currOffset","nextLine","prevLine","prevLineStartOffset","c","lineEndOffset","nextLineEndOffset","line","getLineAndColumnMessage","uniqueId","idCounter","Interval","sourceString","intervals","util.getLineAndColumn","range","util.getLineAndColumnMessage","that","errors.intervalSourcesDontMatch","contents","newStartIdx","firstInterval","MAX_CHAR_CODE","InputStream","nextChar","cp","optIgnoreCase","optEndIdx","MatchResult","matcher","input","startExpr","cst","cstOffset","rightmostFailurePosition","optRecordedFailures","common.defineLazyProperty","detail","errorInfo","matchResultWithFailures","failures","failure","pos","PosInfo","application","headApplication","memoRec","applicationMemoKeyStack","indexOfFirstInvolvedRule","involvedApplicationMemoKeys","applicationMemoKey","memoKey","invalidatedIdx","k","BALLOT_X","CHECK_MARK","DOT_OPERATOR","RIGHTWARDS_DOUBLE_ARROW","SYMBOL_FOR_HORIZONTAL_TABULATION","SYMBOL_FOR_LINE_FEED","SYMBOL_FOR_CARRIAGE_RETURN","Flags","spaces","common.repeat","getInputExcerpt","excerpt","asEscapedString","Trace","pos1","pos2","succeeded","bindings","optChildren","ruleBodyTrace","visitorObjOrFn","optThisArg","visitor","_walk","parent","depth","recurse","child","mask","val","pexprs.any","pexprs.end","pexprs.Terminal","pexprs.Range","pexprs.UnicodeChar","pexprs.Iter","pexprs.Lex","pexprs.Lookahead","pexprs.Not","pexprs.Param","pexprs.Seq","BuiltInRules","g","lexifyCount","pexprs.PExpr","skipSyntacticCheck","ruleInfo","isContextSyntactic","errors.undeclaredRule","errors.applicationOfSyntacticRuleFromLexicalContext","errors.wrongNumberOfArguments","isBuiltInApplySyntactic","errors.incorrectArgumentType","arg","errors.applySyntacticWithLexicalRuleApplication","errors.unnecessaryExperimentalApplySyntactic","errors.invalidParameter","pexprs.Alt","arity","term","otherArity","errors.inconsistentArity","pexprs.Extend","actualArity","expectedArity","errors.kleeneExprHasNullableOperand","Node","matchLength","childIdx","TerminalNode","NonterminalNode","children","childOffsets","common.isLexical","IterationNode","isOptional","common.abstract","state","inputStream","origPos","factor","cols","colOffsets","numMatches","prevPos","row","rowOffsets","lastCol","lastColOffsets","endOffset","pexprs.Opt","caller","posInfo","currentLeftRecursion","origPosInfo","description","origInputStreamExaminedLength","currentLR","isHeadOfLeftRecursion","offsets","lrMemoRec","newValue","seedTrace","getMetaInfo","grammarInterval","metaInfo","adjusted","formals","pexprs.Plus","key","inlined","isRestrictedJSIdentifier","resolveDuplicatedNames","argumentNameList","count","argName","dupArgName","subscript","firstArgIndex","noDupCheck","termArgNameLists","numArgs","colIdx","col","rowIdx","uniqueNames","factorArgumentNameList","exprArgumentString","ps","isValidType","Failure","pexpr","text","t","f","CaseInsensitiveTerminal","param","terminal","matchStr","builtInApplySyntacticBody","builtInRules","applySpaces","MatchState","optPositionToRecordFailures","optNode","currentApplication","newLength","shouldCloneIfNew","memoRecRightmostFailurePosition","origNumBindings","origUserData","origRecordedFailures","memoPos","origTrace","traceEntry","rightmostFailures","matchResult","rootTrace","Matcher","prevInput","memoTable","restOfMemoTable","optStartApplicationStr","options","opts","applicationStr","startApp","globalActionStack","hasOwnProperty","prop","Wrapper","sourceInterval","baseInterval","attributeName","childWrapper","childNode","base","optChildWrappers","childWrappers","childNodes","iter","wrapper","Semantics","superSemantics","self","util.uniqueId","semanticsOnly","hasSuperSemantics","superSemanticsGrammar","relatedGrammar","semanticOperations","actionDict","builtInDefault","signature","method","srcArray","actionName","typePlural","parsedNameAndFormalArgs","parseSignature","newDefaultAction","doIt","realActionDict","Operation","Attribute","thisThing","argsObj","formal","oldArgs","inheritedFormals","inheritedActionDict","newActionDict","optBaseInterval","r","errors.missingSemanticAction","optSuperSemantics","proxy","common.unexpectedObjToString","operationOrAttributeName","action","semantic","semantics","nodeWrapper","actionFn","SPECIAL_ACTION_NAMES","getSortedRuleValues","jsonToJS","ohmGrammar","buildGrammar","Grammar","rules","optDefaultStartRule","myRules","otherRules","rule","optStartApplication","m","what","problems","v","details","prettyProblems","problem","error","superGrammarExpr","startRule","isDefinition","operation","bodyRecipe","superGrammarOutput","recipeElements","first","errors.wrongNumberOfParameters","pexprs.CaseInsensitiveTerminal","pexprs.Star","builderFn","GrammarDecl","errors.cannotOverrideUndeclaredRule","errors.duplicateParameterNames","expectedFormals","expectedNumFormals","primitive","grammarErrors","grammarHasInvalidApplications","errors.throwErrors","errors.duplicateRuleDeclaration","descIgnored","fragment","errors.cannotExtendUndeclaredRule","Builder","defaultStartRule","gDecl","ruleRecipe","termArgs","factorArgs","optParams","pexprs.Splice","recipe","result","makeRecipe","superSplicePlaceholder","namespaceHas","ns","match","optOhmGrammarForTesting","builder","decl","currentRuleName","currentRuleFormals","overriding","grammarIter","id","_open","_close","errors.duplicateGrammarDeclaration","_","superGrammarName","errors.undeclaredGrammar","fs","b","expansionPos","errors.multipleSuperSplices","opointy","cpointy","seqs","inlineRuleName","isNewRuleDeclaration","params","open","close","space1","space2","rest","cs","common.unescapeCodePoint","err","errors.invalidCodePoint","xs","operationsAndAttributesGrammar","initBuiltInSemantics","initPrototypeParser","actions","_children","optFormals","oparen","cparen","findIndentation","topOfStack","regex","indent","indentSize","prevSize","indentPos","prevLength","INDENT_DESCRIPTION","DEDENT_DESCRIPTION","INVALID_CODE_POINT","InputStreamWithIndentation","Indentation","isIndent","pseudoTokens","sign","applyIndent","applyDedent","newAnyBody","IndentationSensitive","isBuffer","compileAndLoad","errors.grammarSyntaxError","optNamespace","grammars","grammarNames","inlinedFunctions","y","min","max","neg","zero","builtInSignals","buffer","sum","SAMPLE_RATE","SAMPLE_RATE_RECIP","TAU","ad","a","stage","adsr","gate","linear","lastValue","epsilon","diff","exponential","legato","jumping","voice","retriggered","toFrequency","midiNote","interpolatedRead","whole","frac","xm1","x0","x1","x2","w","bNeg","fastTanh","clamp","MAX_DELAY_SECONDS","DELAY_BUFFER_SIZE","delay","bufferSize","writePos","readPos","INTERPOLATION","INTERPOLATION_RECIP","SAMPLE_RATE_INTERPOLATION_RECIP","RESONANCE_MULTIPLIER","MIN_CUTOFF_FREQ","MAX_CUTOFF_FREQ","INPUT_THRESHOLD","STATE_DECAY","ladder","mode","_input","_cutoffFreq","_q","z0","z1","alpha","qAdjust","pbg","drive","driveScaled","oldInput","updateFreq","wc","wc2","wc3","wc4","updateResonance","setInputDrive","odrv","setPassbandGain","lpf","ft","weightedSumForCurrentMode","stageOuts0","stageOuts1","stageOuts2","stageOuts3","stageOuts4","total","interp","os","inInterp","u","stage1","stage2","stage3","stage4","msynthLib","phase","sample","phaseInc","naiveSample","polyBlep","integrator","square","sync","prevSyncValue","currSyncValue","syncDetected","glide.linear","glide.exponential","env.ad","env.adsr","env.gate","cf","q","effects.delay","useLastValue","prevX","prevY","dt","CompilerError","ohm.grammar","ANode","Prog","decls","declared","lib","paramNames","refs","builtins","getParamNum","SDecl","MDecl","haveSignal","outputs","ADecl","rhs","mdecls","signals","signal","code","argNames","localRefs","call","subst","AExpr","Call","want","macro","Ref","ref","ANumber","number","_eq","_def","margs","_arrow","es","_plus","_minus","_times","_div","_mod","_oparen","_cparen","_optDollar","_first","_rest","_sep","compile","mr","prog","evalCompiledCode","__","lazy","makeSignal","force","ifZero","Synth","channel","outs","allSignals","d1","d2","d3","note","velocity","vel","retriggerNext","nextNote","output","gain","Msynth","Sequencer","msg","transferObjects","makeSignals","inputs","parameters","numFrames","bpm","steps","notes"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43]}