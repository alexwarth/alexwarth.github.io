(function(){"use strict";function h(n){if(n.length===0)return null;let e=n[0].lengthInFrames;for(let s of n)e=Math.max(e,s.lengthInFrames);return e}const o=1e6*128;class d extends AudioWorkletProcessor{constructor(){super(),this.samplesByLayerId=new Map,this.layers=[],this.recordingLayer=null,this.playhead=0,this.latencyOffsetInChunks=0,this.lastTimePlayheadMovedSent=0,this.port.onmessage=e=>this.onMessage(e.data)}sendMessage(e,s=[]){this.port.postMessage(e,s)}say(e){this.sendMessage({event:"debug",payload:e})}onMessage(e){switch(e.command){case"set latency offset":this.setLatencyOffset(e.value);break;case"change latency offset":this.setLatencyOffset(this.latencyOffsetInChunks+e.by);break;case"start recording":this.startRecording();break;case"stop recording":this.stopRecording();break;case"update layers":this.updateLayers(e.layers);break;case"set layer samples":this.setLayerSamples(e.id,new Float32Array(e.samples));break;default:throw console.error("unsupported message",e),new Error("unsupported message!")}}setLatencyOffset(e){console.log("set latency offset",e),this.latencyOffsetInChunks=e,this.sendMessage({event:"changed latency offset",value:this.latencyOffsetInChunks})}startRecording(){this.recordingLayer||(console.log("start recording!"),this.recordingLayer={id:Math.random(),lengthInFrames:h(this.layers)??-1,frameOffset:this.playhead-this.latencyOffsetInChunks*128,numChannels:1,numFramesRecorded:0,muted:!1,gain:1},this.samplesByLayerId.set(this.recordingLayer.id,new Float32Array(o)),this.say("started recording"))}stopRecording(){if(!this.recordingLayer)return;console.log("stop recording"),this.recordingLayer.lengthInFrames<0&&(this.recordingLayer.lengthInFrames=this.recordingLayer.numFramesRecorded),this.layers.length===0&&this.movePlayhead(this.latencyOffsetInChunks*128);const e=this.samplesByLayerId.get(this.recordingLayer.id).slice(0,this.recordingLayer.numFramesRecorded*this.recordingLayer.numChannels).buffer;this.sendMessage({event:"finished recording",layer:this.recordingLayer,samples:e},[e]),this.layers.push(this.recordingLayer),this.recordingLayer=null}updateLayers(e){console.log("update layers"),this.layers=e}setLayerSamples(e,s){console.log("set layer samples"),this.samplesByLayerId.set(e,s)}process([e],[s],a){const t=s[0].length;for(let r=0;r<t;r++){this.recordingLayer&&(this.mixFrameInto(this.recordingLayer,s,r),this.recordFrame(e,r));for(const i of this.layers)i.muted||this.mixFrameInto(i,s,r);this.advancePlayhead()}return!0}mixFrameInto(e,s,a){if(e.lengthInFrames<0)return;const t=this.playhead%e.lengthInFrames;for(let r=0;r<s.length;r++)s[r][a]+=e.gain*this.getSampleAt(e,r,t)}getSampleAt(e,s,a){if(e.numChannels===1)s=0;else if(e.numChannels<=s)return 0;let t=0,r=(a-e.frameOffset)*e.numChannels+s;const i=e.numFramesRecorded*e.numChannels,l=this.samplesByLayerId.get(e.id);if(!l)return 0;for(;r<i;)r>=0&&(t+=l[r]),r+=e.lengthInFrames*e.numChannels;return t}recordFrame(e,s){if(!this.recordingLayer)throw new Error("called recordFrame() when recordingLayer was null!");if(e.length<this.recordingLayer.numChannels)throw new Error(`recording ${this.recordingLayer.numChannels}-channel layer from ${e.length}-channel input`);let a=this.recordingLayer.numFramesRecorded++*this.recordingLayer.numChannels;const t=this.samplesByLayerId.get(this.recordingLayer.id);for(let r=0;r<this.recordingLayer.numChannels;r++)t[a++]=e[r][s]}advancePlayhead(){if(this.playhead===null)throw new Error("called advancePlayhead() w/ null playhead");const e=h(this.layers);e!==null&&this.movePlayhead((this.playhead+1)%e)}movePlayhead(e){this.playhead=e;const s=Date.now();(this.playhead===0||s-this.lastTimePlayheadMovedSent>16)&&(this.sendMessage({event:"playhead moved",value:this.playhead}),this.lastTimePlayheadMovedSent=s)}}registerProcessor("looper",d)})();
