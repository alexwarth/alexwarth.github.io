(function(){"use strict";function o(h){if(h.length===0)return null;let e=h[0].lengthInFrames;for(let s of h)e=Math.max(e,s.lengthInFrames);return e}const l=1e6*128;class d extends AudioWorkletProcessor{constructor(){super(),this.samplesByLayerId=new Map,this.layers=[],this.recordingLayer=null,this.playhead=0,this.latencyOffsetInChunks=0,this.lastTimePlayheadMovedSent=0,this.port.onmessage=e=>this.onMessage(e.data)}sendMessage(e,s=[]){this.port.postMessage(e,s)}say(e){this.sendMessage({event:"debug",payload:e})}onMessage(e){switch(e.command){case"set latency offset":this.setLatencyOffset(e.value);break;case"change latency offset":this.setLatencyOffset(this.latencyOffsetInChunks+e.by);break;case"start recording":this.startRecording();break;case"stop recording":this.stopRecording();break;case"update layers":this.updateLayers(e.layers);break;case"set layer samples":this.setLayerSamples(e.id,new Float32Array(e.samples));break;default:throw console.error("unsupported message",e),new Error("unsupported message!")}}setLatencyOffset(e){console.log("set latency offset",e),this.latencyOffsetInChunks=e,this.sendMessage({event:"changed latency offset",value:this.latencyOffsetInChunks})}startRecording(){this.recordingLayer||(console.log("start recording!"),this.recordingLayer={id:Math.random(),lengthInFrames:o(this.layers)??-1,frameOffset:this.playhead-this.latencyOffsetInChunks*128,numChannels:1,numFramesRecorded:0,muted:!1,gain:1},this.samplesByLayerId.set(this.recordingLayer.id,new Float32Array(l)),this.say("started recording"))}stopRecording(){if(!this.recordingLayer)return;console.log("stop recording"),this.recordingLayer.lengthInFrames<0&&(this.recordingLayer.lengthInFrames=this.recordingLayer.numFramesRecorded),this.layers.length===0&&this.movePlayhead(this.latencyOffsetInChunks*128);const e=this.samplesByLayerId.get(this.recordingLayer.id).slice(0,this.recordingLayer.numFramesRecorded*this.recordingLayer.numChannels).buffer;this.sendMessage({event:"finished recording",layer:this.recordingLayer,samples:e},[e]),this.layers.push(this.recordingLayer),this.recordingLayer=null}updateLayers(e){console.log("update layers"),this.layers=e}setLayerSamples(e,s){console.log("set layer samples"),this.samplesByLayerId.set(e,s)}process(e,[s],i){const r=e[0],t=s[0].length;for(let a=0;a<t;a++){if(this.recordingLayer){this.mixFrameInto(this.recordingLayer,s,a);try{this.recordFrame(r,a)}catch(n){console.log(n),console.log("inputs",e)}}for(const n of this.layers)n.muted||this.mixFrameInto(n,s,a);this.advancePlayhead()}return!0}mixFrameInto(e,s,i){if(e.lengthInFrames<0)return;const r=this.playhead%e.lengthInFrames;for(let t=0;t<s.length;t++)s[t][i]+=e.gain*this.getSampleAt(e,t,r)}getSampleAt(e,s,i){if(e.numChannels===1)s=0;else if(e.numChannels<=s)return 0;let r=0,t=(i-e.frameOffset)*e.numChannels+s;const a=e.numFramesRecorded*e.numChannels,n=this.samplesByLayerId.get(e.id);if(!n)return 0;for(;t<a;)t>=0&&(r+=n[t]),t+=e.lengthInFrames*e.numChannels;return r}recordFrame(e,s){if(!this.recordingLayer)throw new Error("called recordFrame() when recordingLayer was null!");if(e.length<this.recordingLayer.numChannels)throw new Error(`recording ${this.recordingLayer.numChannels}-channel layer from ${e.length}-channel input`);let i=this.recordingLayer.numFramesRecorded++*this.recordingLayer.numChannels;const r=this.samplesByLayerId.get(this.recordingLayer.id);for(let t=0;t<this.recordingLayer.numChannels;t++)r[i++]=e[t][s]}advancePlayhead(){const e=o(this.layers);this.movePlayhead(e===null?0:(this.playhead+1)%e)}movePlayhead(e){this.playhead=e;const s=Date.now();(this.playhead===0||s-this.lastTimePlayheadMovedSent>16)&&(this.sendMessage({event:"playhead moved",value:this.playhead}),this.lastTimePlayheadMovedSent=s)}}registerProcessor("looper",d)})();
