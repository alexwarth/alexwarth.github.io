(function(){"use strict";function l(o){if(o.length===0)return null;let e=o[0].lengthInFrames;for(let s of o)e=Math.max(e,s.lengthInFrames);return e}const d=1e6*128;class c extends AudioWorkletProcessor{constructor(){super(),this.samplesByLayerId=new Map,this.layers=[],this.recordingLayer=null,this.playhead=0,this.masterGain=1,this.latencyOffsetInChunks=0,this.channelToRecord=0,this.lastTimePlayheadMovedSent=0,this.port.onmessage=e=>this.onMessage(e.data)}sendMessage(e,s=[]){this.port.postMessage(e,s)}say(e){this.sendMessage({event:"debug",payload:e})}onMessage(e){switch(e.command){case"set latency offset":this.setLatencyOffset(e.value);break;case"change latency offset":this.setLatencyOffset(this.latencyOffsetInChunks+e.by);break;case"start recording":this.startRecording();break;case"stop recording":this.stopRecording();break;case"update layers":console.log("update layers"),this.layers=e.layers;break;case"set layer samples":console.log("set layer samples"),this.samplesByLayerId.set(e.id,new Float32Array(e.samples));break;case"set master gain":this.masterGain=e.value;break;case"move playhead":this.movePlayhead(e.value,!0);break;case"set channel to record":this.channelToRecord=e.channel;break;default:throw console.error("unsupported message",e),new Error("unsupported message!")}}setLatencyOffset(e){this.latencyOffsetInChunks=e,this.sendMessage({event:"changed latency offset",value:this.latencyOffsetInChunks})}startRecording(){this.recordingLayer||(this.recordingLayer={id:Math.random(),lengthInFrames:l(this.layers)??-1,frameOffset:this.playhead-this.latencyOffsetInChunks*128,numChannels:1,numFramesRecorded:0,soloed:!1,muted:!1,backwards:!1,gain:1},this.samplesByLayerId.set(this.recordingLayer.id,new Float32Array(d)),this.say("started recording"))}stopRecording(){if(!this.recordingLayer)return;this.recordingLayer.lengthInFrames<0&&(this.recordingLayer.lengthInFrames=this.recordingLayer.numFramesRecorded),this.layers.length===0&&this.movePlayhead(this.latencyOffsetInChunks*128);const e=this.samplesByLayerId.get(this.recordingLayer.id).slice(0,this.recordingLayer.numFramesRecorded*this.recordingLayer.numChannels).buffer;this.sendMessage({event:"finished recording",layer:this.recordingLayer,samples:e},[e]),this.layers.push(this.recordingLayer),this.recordingLayer=null}process(e,[s],n){const i=e[0],a=s[0].length,h=!this.layers.some(r=>r.soloed);for(let r=0;r<a;r++){if(this.recordingLayer){h&&this.mixFrameInto(this.recordingLayer,s,r);try{this.recordFrame(i,r)}catch(t){throw console.log("--- ⬇️⬇️⬇️ ---"),console.log(t),console.log("inputs",e),console.log("--- ⬆️⬆️⬆️ ---"),t}}for(const t of this.layers)(t.soloed||!t.muted&&h)&&this.mixFrameInto(t,s,r);for(let t=0;t<s.length;t++)s[t][r]*=this.masterGain;this.advancePlayhead()}return!0}mixFrameInto(e,s,n){if(e.lengthInFrames<0)return;const i=this.playhead%e.lengthInFrames;for(let a=0;a<s.length;a++)s[a][n]+=e.gain*this.getSampleAt(e,a,i)}getSampleAt(e,s,n){if(e.numChannels===1)s=0;else if(e.numChannels<=s)return 0;let i=0,a=(n-e.frameOffset)*e.numChannels+s;const h=e.numFramesRecorded*e.numChannels,r=this.samplesByLayerId.get(e.id);if(!r)return 0;const t=e.numFramesRecorded/e.numChannels;for(;a<h;)a>=0&&(i+=r[e.backwards?t-a-1:a]),a+=e.lengthInFrames*e.numChannels;return i}recordFrame(e,s){if(!this.recordingLayer)throw new Error("called recordFrame() when recordingLayer was null!");if(e.length<this.recordingLayer.numChannels)throw new Error(`recording ${this.recordingLayer.numChannels}-channel layer from ${e.length}-channel input`);let n=this.recordingLayer.numFramesRecorded++*this.recordingLayer.numChannels;const i=this.samplesByLayerId.get(this.recordingLayer.id);i[n++]=e[this.channelToRecord][s]}advancePlayhead(){const e=l(this.layers);this.movePlayhead(e===null?0:(this.playhead+1)%e)}movePlayhead(e,s=!1){this.playhead=e;const n=Date.now();(this.playhead===0||s||n-this.lastTimePlayheadMovedSent>16)&&(this.sendMessage({event:"playhead moved",value:this.playhead}),this.lastTimePlayheadMovedSent=n)}}registerProcessor("looper",c)})();
